\chapter{Динамическое программирование}

\noindent\fbox{
	\parbox{\linewidth}{
		\qquad Динамическое программирование эффективно, если процесс принятия  решения состоит из многих шагов, то есть когда итоговое решение --- последовательность принимаемых решений (\definitionfont{стратегия}). Теоретически с помощью динамического программирования можно решить любую экстремальную задачу, однако практически это не всегда возможно, так как появляется слишком много состояний... \textbf{Главная идея динамического программирования} заключается в том, чтобы не пытаться решить задачу непосредственно, а поместить её в семейство аналогичных задач, среди которых есть просто решаемые.
	}
}

\section{Задача загрузки судна}

\problem

Есть грузовое судно и набор различных контейнеров. Требуется загрузить судно контейнерами таким образом, чтобы при их дальнейшей продаже заработать как можно больше.

\bigskip

\textbf{Формальное описание}:
\begin{itemize}[nosep]
	\item есть $N$ контейнеров;
	
	\item $x_i$ --- сколько контейнеров с номером $i$ нужно взять на судно;
	
	\item $h_i$ --- место на грузовой площадке, занимаемое контейнером с номером $i$;
	
	\item $c_i$ --- ценность контейнера с номером $i$;
	
	\item $P$ --- размер грузовой площадки судна;
\end{itemize}

\[
	\sum_{i=1}^{N} c_i x_i \to \max_{(x_i), \; i \in \{1, \dots, N\}}
\]
\[
	\sum_{i=1}^{N} h_i x_i \le P
\]
\[
	x_i \in \{0, 1, 2, 3, \dots\}, \quad i \in {1, \dots N}
\]

\solution

Для решения задачи рассмотрим семейство аналогичных задач. Задачи данного семейства будут охарактеризовываться парой $(n, p)$, где
\begin{itemize}[nosep]
	\item $p$ --- место на площадке;
	
	\item $n$ --- минимальный номер для контейнеров, которые у нас есть.
\end{itemize}

\[
	n = 1 \dots N \qquad p = 0 \dots P.
\]

Вместо рассмотрения общей задачи про все $N$ контейнеров и всю грузовую площадку размером $P$ будем рассматривать задачи, в которых нам <<доступны>> не все контейнеры, а лишь начинающиеся с номера $n$, а также в которых нам <<недоступна>> вся грузовая площадка судна, а лишь её часть размером $p$.

Запишем целевую функцию и ограничения для элемента семейства
\[
	\sum_{i=n}^{N} c_i x_i \to \max_{(x_i), \; i \in \{n, \dots N\}}
\]
\[
	\sum_{i=n}^{N} h_i x_i \le p
\]
\[
	x_i \in \{0, 1, 2, 3, \dots\} \quad i \in \{n, \dots, N\}
\]

Мы формально записали формулировку задачи для некоторого элемента семейства, при этом этот элемент характеризуется парой $(n, p)$.

Зададимся вопросом: а есть ли в этом семействе задачи, которые можно легко решить? Да, например если $n = N$, то есть если у нас в распоряжении есть лишь контейнеры с номером $N$.

\textbf{Введём обозначение}. Пусть $\boxed{f_n(p)}$ --- оптимальное значение целевой функции задачи $(n, p)$. По своей суть $f_n(p)$ ---это максимальный доход, который мы получим, если будем на площадку размера $p$ грузить контейнеры с номерами $n, n+1, n+2, \dots, N$.

Легко заметить, что
\[
	f_N(p) = \bigg[\frac{p}{h_N}\bigg],
\]

то есть решать задачу $(N, p)$ для любого $p \le P$ мы умеем. Теперь нужно совершить переход к решению исходной задачи
\[
	f_N(p) \longrightarrow f_1(P).
\]

Для этого сформулируем принцип.

\definition[принцип оптимальности для оптимальной стратегии]

\definitionfont{Оптимальная стратегия обладает тем свойством, что каким бы не было первое решение, последующие решения должны образовывать оптимальную стратегию относительно состояния, полученного по итогам первого решения}.

\example

Пусть мы стоим у доски и нам захотелось как можно быстрее выйти из аудитории через дверь. Каким бы ни был наш первый шаг, если мы хотим дойти до двери как можно быстрее, придётся всё время действовать оптимально. То есть даже если первый шаг был оптимальным, но потом мы накосячили и пошли неоптимально, стратегия точно не получится оптимальной.

\bigskip

\textbf{Вернёмся к задаче}. Предположим, что мы умеем считать
\[
	f_{n+1}(p), f_{n+2}(p), \dots, f_{N}(p),
\]

однако нам бы хотелось посчитать $f_n(p)$, как это можно сделать? Предположим, что $x_n = x = 1$, тогда груз с номером $n$ даст нам ценность $c_n \cdot x = c_n$ и займёт на площадке место $h_n \cdot x = h_n$. Запишем целевую функцию
\[
	\forall p \le P \qquad f_n(p) = \max_{h_n \cdot x \le p, \; x = 0, 1, 2, \dots} \big\{c_n \cdot x + f_{n+1}(p - h_n \cdot x)\big\}.
\]

Мы получили \textbf{рекуррентное соотношение динамического программирования}. На данном этапе $f_n(p)$ можно получить перебором значение $x_n = x$, а $f_{n+1}(\dots)$ нам уже известно.

Какой здесь будет алгоритм при реализации? Алгоритм будет включать в себя $N$ шагов, на каждом из которых мы будем вычислять $f_n(p)$. По сути мы будем заполнять табличку

\begin{table}[h!]
	\centering
	\begin{tabular}{|c|  c | c | c | c | c| c|} 
		\hline
		$p$ & $f_1(p)$ & $f_2(p)$ & $\dots$ & $f_n(p)$ & $f_{N-1}(p)$ & $f_N(p)$\\ [0.5ex] 
		\hline
		0 & $\times$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ \\ 
		1 & $\times$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ \\
		2 & $\times$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ \\
		3 & $\times$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ \\
		$\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ \\
		$P-1$ & $\times$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ \\
		$P$ & $\dots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ & $\vdots$ \\ [1ex] 
		\hline
	\end{tabular}
\end{table}

Для решения задачи нам важно лишь $f_1(P)$, считать $f_1(p)$ для всех $p \le P$ не нужно.

Алгоритм имеет две стадии:
\begin{enumerate}[nosep]
	\item \textit{обратный ход} $N \to 1$ --- заполнение таблицы,
	
	\item \textit{прямой ход} $1 \to N$ --- вычисление оптимального решения.
\end{enumerate}

Сначала мы будем идти с конца и для всех значений $p$ считать $f_N(p)$. Потом на основании этого будем для всех значений $p$ считать $f_{N-1}(p)$ и так далее. Когда мы заполним все столбцы, кроме $f_1(p)$, мы посчитаем $f_1(P)$ и на этом заполнение таблички закончим.

Как теперь по табличке получить само оптимальное решение --- отдельный вопрос, который будет рассмотрен позже.

\section{$N$-шаговый процесс принятия решений}