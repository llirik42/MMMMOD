\chapter{Сетевые модели}

\section{Теория графов}

\definition

\definitionfont{Графом} называется пара множеств $G = (V, E)$, где

\begin{itemize}[nosep]
	\item $V$ --- \definitionfont{множество вершин},
	
	\item $E \subseteq V \times V$ --- \definitionfont{множество рёбер}. 
\end{itemize}

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=1.5]
		\node[vertex, label=above:$v_1$] (v1) at (0,0) {};
		\node[vertex, label=left:$v_2$] (v2) at (-1,-1) {};
		\node[vertex, label=right:$v_3$] (v3) at (-1,-3) {};
		\node[vertex, label=above:$v_4$] (v4) at (0.5,-1.5) {};
		\node[vertex, label=right:$v_5$] (v5) at (1.5,-2.5) {};
	
		\draw (v1) -- node[left] {$e_1$} (v2);
		\draw (v2) -- node[left] {$e_3$} (v3);
		\draw (v2) -- node[above] {$e_2$} (v4);
		\draw (v4) -- node[above] {$e_4$} (v5);
	\end{tikzpicture}
	\caption{Пример графа}
\end{figure}

\definition

Вершины называются \definitionfont{смежными}, если они соединены ребром.

\definition

\definitionfont{Ориентированным графом} называется пара множеств $G = (V, E)$, где

\begin{itemize}[nosep]
	\item $V$ --- \definitionfont{множество вершин},
	
	\item $E \subseteq V \times V$ --- \definitionfont{множество дуг}.
\end{itemize}

Будем обозначать дугу от вершины $x$ до вершины $y$ как $\vec{xy}$.

\remark

В неориентированном графе если множество рёбер $E$ содержит ребро $(v_i, v_j)$, то оно также содержит ребро $(v_j, v_i)$. Гарантировать то же самое в ориентированном графе нельзя.

\remark

В дальнейшем для простоты будем считать, что

\begin{itemize}[nosep]
	\item $V = \{1, 2, \dots, n\}$,
	
	\item $E = \{1, 2, \dots, m\}$.
\end{itemize}

\definition

Пусть каждая дуга $j$ ориентированного графа имеет некоторый вес $c(j)$, тогда \definitionfont{табличным видом ориентированного графа} будем называть следующую таблицу

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c | c | } 
		\hline
		$j$ & $i(j)$ & $k(j)$ & $c(j)$ \\ \hline
		$1$ &&& \\ \hline
		$1$ &&& \\ \hline
		$\dots$ &&&\\\hline
		$m$ &&& \\ \hline
	\end{tabular}
\end{table}

\begin{itemize}[nosep]
	\item $j$ --- дуга,
	
	\item $i(j)$ --- начальная точка дуги,
	
	\item $k(j)$ --- конечная точка дуги,
	
	\item $c(j)$ --- вес дуги.
\end{itemize}

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=1.5]
		\node[vertex, label=above:$i(j)$] (i) at (-1,-1) {};
		\node[vertex, label=left:$k(j)$] (k) at (1,1) {};
		
		\draw[->, edge] (i) -- node[left] {$j$} (k);
	\end{tikzpicture}
	\caption{Пример дуги $j$}
\end{figure}

\definition

\definitionfont{Путь} в графе от вершины $i_1$ до $i_k$ --- последовательность неповторяющихся вершин. Будем обозначать это как $p(i_1, \dots, i_k)$ или $\{i_1, \dots, i_k\}$, где $(i_l, i_{l+1}) \in E$.

\remark

В рамках данного курса не будут рассматриваться пути, являющиеся циклами, то есть всегда $i_1 \neq i_k$.

\definition

\definitionfont{Сеть} --- ориентированных граф $G = (V, E)$, в котором

\begin{itemize}[nosep]
	\item есть 2 выделенные вершины $s$ (источник/вход) и $t$ (сток/выход);
	
	\item на множествах вершин и рёбер определён строгий порядок.
\end{itemize}

Вершины $s$ и $t$ определяется так: $s$ --- наименьшая вершина, в которую не входит дуга; а $t$ --- наибольшая вершина, из которой не выходит дуга.

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=1.5]
		\node[vertex, label=left:\textcolor{blue}{$s$}, fill=blue] (s) at (-3,0) {};
		\node[vertex, label=right:\textcolor{blue}{$t$}, fill=blue] (t) at (1,0) {};
		\node[vertex] (v1) at (-1.6, -0.2) {};
		\node[vertex] (v2) at (-0.5, -0.6) {};
		\node[vertex] (v3) at (-0.9, 0.5) {};
		\node[vertex] (v4) at (-0.5, 1) {};
		
		\draw[->, edge] (s) -- node[left] {} (v1);
		\draw[->, edge] (v1) -- node[left] {} (v2);
		\draw[->, edge] (v1) -- node[left] {} (v3);
		\draw[->, edge] (v3) -- node[left] {} (t);
		\draw[->, edge] (v2) -- node[left] {} (t);
		\draw[->, edge] (v3) -- node[left] {} (v4);
		\draw[->, edge] (s) to[bend left=60] (t);
		\draw[->, edge] (s) to[bend right=60] (t);
	\end{tikzpicture}
	\caption{Пример сети}
\end{figure}

\section{Сетевая модель проекта}

\definition

\definitionfont{Проект} --- совокупность работ для достижения определённой цели. \definitionfont{Модель проекта} определяется следующим образом:

\begin{itemize}[nosep]
	\item $J = \{1, \dots, n\}$ --- множество работ проекта,
	
	\item $\tau_{j} \ge 0$ --- длительность работы $j$;
	
	\item $C = \big\{(i, j) \; \big| \; i,j \in J\big\}$ --- частичный порядок, работа $j$ не может начаться раньше окончанию работы $i$.
\end{itemize}

Модель проекта можно записать с помощью следующей таблицы

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c | } 
		\hline
		$j$ & \text{следующие работы} & $\tau_j$ \\ \hline
		$j_0$ & $j_1$, $j_2$, $\dots$ & $\tau_{j_0}$ \\ \hline
		$\dots$ & $\dots$ & $\dots$ \\ \hline
	\end{tabular}
\end{table}

При этом, <<следующие работы>> для работы $j$ --- это работы, которые зависят от $j$, то есть которые не могут начаться раньше, чем завершится работа $j$.

\example\label{ex:office_project}

Рассмотрим следующую модель проекта:

\begin{itemize}[nosep]
	\item $\mathbf{J} = \{1, 2, \dots, 9, 10\}$ --- множество работ проекта,
	
	\item $1$ --- выбрать место для офиса,
	
	\item $2$ --- создать финансовый и организационный план,
	
	\item $3$ --- определить обязанности персонала,
	
	\item $4$ --- разработать план офиса,
	
	\item $5$ --- ремонт помещений,
	
	\item $6$ --- отобрать кандидатов на увольнение,
	
	\item $7$ --- нанять новых служащих,
	
	\item $8$ --- назначить ключевых руководителей,
	
	\item $9$ --- распределить обязанности руководителей,
	
	\item $10$ --- обучить персонал;
\end{itemize}

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c | } 
		\hline
		$j$ & \text{следующие работы} & $\tau_j$ \\ \hline
		$1$ & $\{4\}$ & $3$ \\ \hline
		$2$ & $\{3, 9\}$ & $5$ \\ \hline
		$3$ & $\{4, 6\}$ & $3$ \\ \hline
		$4$ & $\{5\}$ & $5$ \\ \hline
		$5$ & $\{10\}$ & $10$ \\ \hline
		$6$ & $\{7, 8\}$ & $2$ \\ \hline
		$7$ & $\{10\}$ & $5$ \\ \hline
		$8$ & $\{10\}$ & $2$ \\ \hline
		$9$ & $\O$ & $5$ \\ \hline
		$10$ & $\O$ & $3$ \\ \hline
	\end{tabular}
\end{table}

\definition

\definitionfont{Сетевая модель проекта} --- наглядное представление работ в виде сети, в которой для каждой работы есть дуга, а отношение следования работ в проекте имеет место и в сети.

\definitionfont{Сетевая модель проекта} --- ориентированный взвешенный граф без циклов $G = (V, E)$ с выделенными вершинами $s$ и $t$, при этом каждой дуге $j = \vec{ik}$ приписан вес $\tau_j \ge 0$. Вершинами сети будут \definitionfont{события} (результаты выполнения работ), а дугами сами работы.

\textbf{Обозначение}: \circled{1} --- вершина с номером $1$, \squared{1} --- дуга с номером $1$.

\example

Изобразим сетевую модель проекта из \hyperref[ex:office_project]{примера}.

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=2.2]
		\node[vertex, label=left:\textcolor{blue}{\circled{1}}, fill=blue] (1) at (-3,0) {};
		\node[vertex, label=right:\textcolor{blue}{\circled{9}}, fill=blue] (9) at (4,-1) {};
		\node[vertex, label={\circled{4}}] (4) at (-2.3,0.7) {};
		\node[vertex, label={\circled{2}}] (2) at (-2.3,-0.7) {};
		\node[vertex, label={\circled{5}}] (5) at (0,0.7) {};
		\node[vertex, label={\circled{8}}] (8) at (2.2,0.7) {};
		\node[vertex, label={\circled{3}}] (3) at (-0.8,-0.7) {};
		\node[vertex, label={\circled{6}}] (6) at (0.7,-0.7) {};
		\node[vertex] (7) at (2.2,-0.7) {};
		
		\node at (1.3,0.2) {\squared{7}};
		\node at (3.5, 0) {\squared{10}};
		\node at (2, -1.4) {\squared{9}};
		\node at (-1.4, 0.2) {\squared{11}};
		\node at (2.4, -0.6) {\circled{7}};
		\node at (2.45, 0.1) {\squared{12}};
		
		\draw[->, edge] (1) -- node[above left] {\squared{1}} (4);
		\draw[->, edge] (1) -- node[below left] {\squared{2}} (2);
		\draw[->, edge] (4) -- node[above] {\squared{4}} (5);
		\draw[->, edge] (5) -- node[above] {\squared{5}} (8);
		\draw[->, edge] (6) -- node[above] {} (8);
		\draw[->, edge] (6) -- node[above] {\squared{8}} (7);
		\draw[->, edge] (2) -- node[above] {\squared{3}} (3);
		\draw[->, edge] (3) -- node[above] {\squared{6}} (6);
		\draw[->, edge, dashed] (3) -- node {} (4);
		\draw[->, edge] (2) to[bend right=10] (9);
		\draw[->, edge] (8) to[bend left=10] (9);
		\draw[->, edge, dashed] (7) -- node[above] {} (8);
	\end{tikzpicture}
	\caption{Сеть для проекта из примера. Дуги $11$ и $12$ является фиктивными, то есть не соответствуют работам из модели проекта, они нужны для целостности сети.}
\end{figure}

\algorithm[построения сетевой модели]

\begin{enumerate}[nosep]
	\item[]
	
	\item Для каждой работы строим вершины и дуги.
	
	\item Обозначаем подчинённость, рисуя фиктивные дуги из конца текущей работы в следующую в соответствии с проектом.
	
	\item Добавляем начальную и конечную вершины $s$ и $t$.
	
	\item Убираем фиктивные дуги так, чтобы граф не перестал быть сетью, а также чтобы не появились параллельные дуги. Фиктивную дугу можно убрать, если она единственная, которая входит в вершину или выходит из вершины.
	
	\item Пронумеровываем вершины сети так, чтобы для каждой дуги $j$ выполнялось $i(j) < k(j)$.
\end{enumerate}

\subsection{Алгоритм Форда}

\definition

\definitionfont{Рангом} $r(x)$ вершины $x \in V$ называется число дуг в максимальном (по числу дуг) пути из начальной вершины $s$ в вершину $x$. \definitionfont{Рангом проекта} называется $r(t)$ (ранг стока/выхода/конечной вершины).

\algorithm[Форда]

Алгоритм позволяет устанавливать ранги в сети так, чтобы нумерация вершин оказалось корректной с точки зрения условия $i(j) < k(j)$.

\textbf{Суть алгоритма} в следующем:

\begin{itemize}[nosep]
	\item в каждый момент времени будем для каждой вершины $k$ хранить её текущий ранг $r_k$ (изначально все $r_k = 0$);
	
	\item на каждой итерации будем последовательно просматривать все работы из множества $J$ от наименьшей к наибольшей и менять ранг вершин следующим образом: пусть текущая работа --- это $j = (i, k)$, тогда
	\[
	r_k = \max\{r_k, r_i+1\};
	\]
	
	\item алгоритм будет повторяться до тех пор, пока ранги вершин не перестанут меняться.
\end{itemize}

Для удобства ранги вершин можно записывать в таблицу

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c | c | c | } 
		\hline
		$k$ & $r_k^0$ & $r_k^1$ & $r_k^2$ & $\dots$ \\\hline
		$1$ & $0$ & $\dots$ & $\dots$ & $\dots$ \\\hline
		$2$ & $0$ & $\dots$ & $\dots$ & $\dots$ \\\hline
		$\dots$ & $\dots$ & $\dots$ & $\dots$ & $\dots$ \\\hline
		$n$ & $0$ & $\dots$ & $\dots$ & $\dots$ \\\hline
	\end{tabular}
\end{table}

где $r_k^i$ --- ранг вершины $k$ на шаге $i$.

\remark

Значение $r_k$ для одной и той же вершины $k$ может меняться несколько раз в течение одного шага.

\remark

Если сеть относительно небольшая, то быстрее будет <<вручную>> пронумеровать вершины, а не пользоваться алгоритмом Форда.

\fact

Алгоритм Форда создаёт корректную нумерацию вершин в сети.
