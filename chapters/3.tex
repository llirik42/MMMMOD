\chapter{Сетевые модели}

\section{Теория графов}

\definition

\definitionfont{Графом} называется пара множеств $G = (V, E)$, где

\begin{itemize}[nosep]
	\item $V$ --- \definitionfont{множество вершин},
	
	\item $E \subseteq V \times V$ --- \definitionfont{множество рёбер}. 
\end{itemize}

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=1.5]
		\node[vertex, label=above:$v_1$] (v1) at (0,0) {};
		\node[vertex, label=left:$v_2$] (v2) at (-1,-1) {};
		\node[vertex, label=right:$v_3$] (v3) at (-1,-3) {};
		\node[vertex, label=above:$v_4$] (v4) at (0.5,-1.5) {};
		\node[vertex, label=right:$v_5$] (v5) at (1.5,-2.5) {};
	
		\draw (v1) -- node[left] {$e_1$} (v2);
		\draw (v2) -- node[left] {$e_3$} (v3);
		\draw (v2) -- node[above] {$e_2$} (v4);
		\draw (v4) -- node[above] {$e_4$} (v5);
	\end{tikzpicture}
	\caption{Пример графа}
\end{figure}

\definition

Вершины называются \definitionfont{смежными}, если они соединены ребром.

\definition

\definitionfont{Ориентированным графом} называется пара множеств $G = (V, E)$, где

\begin{itemize}[nosep]
	\item $V$ --- \definitionfont{множество вершин},
	
	\item $E \subseteq V \times V$ --- \definitionfont{множество дуг}.
\end{itemize}

Будем обозначать дугу от вершины $x$ до вершины $y$ как $\vec{xy}$.

\remark

В неориентированном графе если множество рёбер $E$ содержит ребро $(v_i, v_j)$, то оно также содержит ребро $(v_j, v_i)$. Гарантировать то же самое в ориентированном графе нельзя.

\remark

В дальнейшем для простоты будем считать, что

\begin{itemize}[nosep]
	\item $V = \{1, 2, \dots, n\}$,
	
	\item $E = \{1, 2, \dots, m\}$.
\end{itemize}

\definition

Пусть каждая дуга $j$ ориентированного графа имеет некоторый вес $c(j)$, тогда \definitionfont{табличным видом ориентированного графа} будем называть следующую таблицу

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c | c | } 
		\hline
		$j$ & $i(j)$ & $k(j)$ & $c(j)$ \\ \hline
		$1$ &&& \\ \hline
		$1$ &&& \\ \hline
		$\dots$ &&&\\\hline
		$m$ &&& \\ \hline
	\end{tabular}
\end{table}

\begin{itemize}[nosep]
	\item $j$ --- дуга,
	
	\item $i(j)$ --- начальная точка дуги,
	
	\item $k(j)$ --- конечная точка дуги,
	
	\item $c(j)$ --- вес дуги.
\end{itemize}

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=1.5]
		\node[vertex, label=above:$i(j)$] (i) at (-1,-1) {};
		\node[vertex, label=left:$k(j)$] (k) at (1,1) {};
		
		\draw[->, edge] (i) -- node[left] {$j$} (k);
	\end{tikzpicture}
	\caption{Пример дуги $j$}
\end{figure}

\definition

\definitionfont{Путь} в графе от вершины $i_1$ до $i_{L+1}$ --- последовательность неповторяющихся вершин. Будем обозначать это как $P(i_1, \dots, i_{L+1})$ или $\{i_1, \dots, i_{L+1}\}$, где $(i_l, i_{l+1}) \in E$.

\remark

В рамках данного курса не будут рассматриваться пути, являющиеся циклами, то есть всегда $i_1 \neq i_k$.

\definition

\definitionfont{Сеть} --- ориентированных граф $G = (I, J)$, в котором

\begin{itemize}[nosep]
	\item есть 2 выделенные вершины $s$ (источник/вход) и $t$ (сток/выход);
	
	\item на множествах вершин и рёбер определён строгий порядок.
\end{itemize}

Вершины $s$ и $t$ определяется так: $s$ --- наименьшая вершина, в которую не входит дуга; а $t$ --- наибольшая вершина, из которой не выходит дуга.

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=1.5]
		\node[vertex, label=left:\textcolor{blue}{$s$}, fill=blue] (s) at (-3,0) {};
		\node[vertex, label=right:\textcolor{blue}{$t$}, fill=blue] (t) at (1,0) {};
		\node[vertex] (v1) at (-1.6, -0.2) {};
		\node[vertex] (v2) at (-0.5, -0.6) {};
		\node[vertex] (v3) at (-0.9, 0.5) {};
		\node[vertex] (v4) at (-0.5, 1) {};
		
		\draw[->, edge] (s) -- node[left] {} (v1);
		\draw[->, edge] (v1) -- node[left] {} (v2);
		\draw[->, edge] (v1) -- node[left] {} (v3);
		\draw[->, edge] (v3) -- node[left] {} (t);
		\draw[->, edge] (v2) -- node[left] {} (t);
		\draw[->, edge] (v3) -- node[left] {} (v4);
		\draw[->, edge] (s) to[bend left=60] (t);
		\draw[->, edge] (s) to[bend right=60] (t);
	\end{tikzpicture}
	\caption{Пример сети}
\end{figure}

\begin{definition}
	Сеть называется \definitionfont{взвешенной}, если у каждой дуги $j$ есть некоторой вес $\tau_j$. Тогда такую сеть можно задать с помощью следующей таблицы
	
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | c | c |} 
			\hline
			$j$ & $i(j)$ & $k(j)$ & $c(j)$ & $\tau_j$ \\ \hline
			$1$ &&&& \\ \hline
			$1$ &&&& \\ \hline
			$\dots$ &&&& \\\hline
			$m$ &&&& \\ \hline
		\end{tabular}
	\end{table}
\end{definition}

\section{Сетевая модель проекта}

\definition

\definitionfont{Проект} --- совокупность работ для достижения определённой цели. \definitionfont{Модель проекта} определяется следующим образом:

\begin{itemize}[nosep]
	\item $J = \{1, \dots, n\}$ --- множество работ проекта,
	
	\item $\tau_{j} \ge 0$ --- длительность работы $j$;
	
	\item $C = \big\{(i, j) \; \big| \; i,j \in J\big\}$ --- частичный порядок, работа $j$ не может начаться раньше окончанию работы $i$.
\end{itemize}

Модель проекта можно записать с помощью следующей таблицы

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c | } 
		\hline
		$j$ & \text{следующие работы} & $\tau_j$ \\ \hline
		$j_0$ & $j_1$, $j_2$, $\dots$ & $\tau_{j_0}$ \\ \hline
		$\dots$ & $\dots$ & $\dots$ \\ \hline
	\end{tabular}
\end{table}

При этом, <<следующие работы>> для работы $j$ --- это работы, которые зависят от $j$, то есть которые не могут начаться раньше, чем завершится работа $j$.

\example\label{ex:office_project}

Рассмотрим следующую модель проекта:

\begin{itemize}[nosep]
	\item $J = \{1, 2, \dots, 9, 10\}$ --- множество работ проекта,
	
	\item $1$ --- выбрать место для офиса,
	
	\item $2$ --- создать финансовый и организационный план,
	
	\item $3$ --- определить обязанности персонала,
	
	\item $4$ --- разработать план офиса,
	
	\item $5$ --- ремонт помещений,
	
	\item $6$ --- отобрать кандидатов на увольнение,
	
	\item $7$ --- нанять новых служащих,
	
	\item $8$ --- назначить ключевых руководителей,
	
	\item $9$ --- распределить обязанности руководителей,
	
	\item $10$ --- обучить персонал;
\end{itemize}

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c | } 
		\hline
		$j$ & \text{следующие работы} & $\tau_j$ \\ \hline
		$1$ & $\{4\}$ & $3$ \\ \hline
		$2$ & $\{3, 9\}$ & $5$ \\ \hline
		$3$ & $\{4, 6\}$ & $3$ \\ \hline
		$4$ & $\{5\}$ & $5$ \\ \hline
		$5$ & $\{10\}$ & $10$ \\ \hline
		$6$ & $\{7, 8\}$ & $2$ \\ \hline
		$7$ & $\{10\}$ & $5$ \\ \hline
		$8$ & $\{10\}$ & $2$ \\ \hline
		$9$ & $\O$ & $5$ \\ \hline
		$10$ & $\O$ & $3$ \\ \hline
	\end{tabular}
\end{table}

\definition

\definitionfont{Сетевая модель проекта} --- наглядное представление работ в виде сети, в которой для каждой работы есть дуга, а отношение следования работ в проекте имеет место и в сети.

\definitionfont{Сетевая модель проекта} --- ориентированный взвешенный граф без циклов $G = (V, E)$ с выделенными вершинами $s$ и $t$, при этом каждой дуге $j = \vec{ik}$ приписан вес $\tau_j \ge 0$. Вершинами сети будут \definitionfont{события} (результаты выполнения работ), а дугами сами работы.

\textbf{Обозначение}: \circled{1} --- вершина с номером $1$, \squared{1} --- дуга с номером $1$.

\example

Изобразим сетевую модель проекта из \hyperref[ex:office_project]{примера}.

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=2.2]
		\node[vertex, label=left:\textcolor{blue}{\circled{1}}, fill=blue] (1) at (-3,0) {};
		\node[vertex, label=right:\textcolor{blue}{\circled{9}}, fill=blue] (9) at (4,-1) {};
		\node[vertex, label={\circled{4}}] (4) at (-2.3,0.7) {};
		\node[vertex, label={\circled{2}}] (2) at (-2.3,-0.7) {};
		\node[vertex, label={\circled{5}}] (5) at (0,0.7) {};
		\node[vertex, label={\circled{8}}] (8) at (2.2,0.7) {};
		\node[vertex, label={\circled{3}}] (3) at (-0.8,-0.7) {};
		\node[vertex, label={\circled{6}}] (6) at (0.7,-0.7) {};
		\node[vertex] (7) at (2.2,-0.7) {};
		
		\node at (1.3,0.2) {\squared{7}};
		\node at (3.5, 0) {\squared{10}};
		\node at (2, -1.4) {\squared{9}};
		\node at (-1.4, 0.2) {\squared{11}};
		\node at (2.4, -0.6) {\circled{7}};
		\node at (2.45, 0.1) {\squared{12}};
		
		\draw[->, edge] (1) -- node[above left] {\squared{1}} (4);
		\draw[->, edge] (1) -- node[below left] {\squared{2}} (2);
		\draw[->, edge] (4) -- node[above] {\squared{4}} (5);
		\draw[->, edge] (5) -- node[above] {\squared{5}} (8);
		\draw[->, edge] (6) -- node[above] {} (8);
		\draw[->, edge] (6) -- node[above] {\squared{8}} (7);
		\draw[->, edge] (2) -- node[above] {\squared{3}} (3);
		\draw[->, edge] (3) -- node[above] {\squared{6}} (6);
		\draw[->, edge, dashed] (3) -- node {} (4);
		\draw[->, edge] (2) to[bend right=10] (9);
		\draw[->, edge] (8) to[bend left=10] (9);
		\draw[->, edge, dashed] (7) -- node[above] {} (8);
	\end{tikzpicture}
	\caption{Сеть для проекта из примера. Дуги $11$ и $12$ является фиктивными, то есть не соответствуют работам из модели проекта, они нужны для целостности сети.}
\end{figure}

\algorithm[построения сетевой модели]

\begin{enumerate}[nosep]
	\item[]
	
	\item Для каждой работы строим вершины и дуги.
	
	\item Обозначаем подчинённость, рисуя фиктивные дуги из конца текущей работы в следующую в соответствии с проектом.
	
	\item Добавляем начальную и конечную вершины $s$ и $t$.
	
	\item Убираем фиктивные дуги так, чтобы граф не перестал быть сетью, а также чтобы не появились параллельные дуги. Фиктивную дугу можно убрать, если она единственная, которая входит в вершину или выходит из вершины.
	
	\item Пронумеровываем вершины сети так, чтобы для каждой дуги $j$ выполнялось $i(j) < k(j)$.
\end{enumerate}

\subsection{Алгоритм Форда}

\definition

\definitionfont{Рангом} $r(x)$ вершины $x \in V$ называется число дуг в максимальном (по числу дуг) пути из начальной вершины $s$ в вершину $x$. \definitionfont{Рангом проекта} называется $r(t)$ (ранг стока/выхода/конечной вершины).

\algorithm[Форда]

Алгоритм позволяет устанавливать ранги в сети так, чтобы нумерация вершин оказалось корректной с точки зрения условия $i(j) < k(j)$.

\textbf{Суть алгоритма} в следующем:

\begin{itemize}[nosep]
	\item в каждый момент времени будем для каждой вершины $k$ хранить её текущий ранг $r_k$ (изначально все $r_k = 0$);
	
	\item на каждой итерации будем последовательно просматривать все работы из множества $J$ от наименьшей к наибольшей и менять ранг вершин следующим образом: пусть текущая работа --- это $j = (i, k)$, тогда
	\[
	r_k = \max\{r_k, r_i+1\};
	\]
	
	\item алгоритм будет повторяться до тех пор, пока ранги вершин не перестанут меняться.
\end{itemize}

Для удобства ранги вершин можно записывать в таблицу

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c | c | c | } 
		\hline
		$k$ & $r_k^0$ & $r_k^1$ & $r_k^2$ & $\dots$ \\\hline
		$1$ & $0$ & $\dots$ & $\dots$ & $\dots$ \\\hline
		$2$ & $0$ & $\dots$ & $\dots$ & $\dots$ \\\hline
		$\dots$ & $\dots$ & $\dots$ & $\dots$ & $\dots$ \\\hline
		$n$ & $0$ & $\dots$ & $\dots$ & $\dots$ \\\hline
	\end{tabular}
\end{table}

где $r_k^i$ --- ранг вершины $k$ на шаге $i$.

\remark

Значение $r_k$ для одной и той же вершины $k$ может меняться несколько раз в течение одного шага.

\remark

Если сеть относительно небольшая, то быстрее будет <<вручную>> пронумеровать вершины, а не пользоваться алгоритмом Форда.

\fact

Алгоритм Форда создаёт корректную нумерацию вершин в сети.

\section{Поиск максимальных путей}

\definition

Длиной пути $P(i_1, \dots, i_{L+1})$ в некоторой сети будем называть
\[
\abs{P(i_1, \dots, i_{L+1})} = \sum_{l=1}^{L} \tau_{(i_l, i_{l+1})}
\]

\remark

Вместо суммы может стоять произведение, взятие максимума/минимума и так далее (всё зависит от конкретной задачи и сети).

\algorithm[поиска максимальных путей]

Пусть есть некоторой сеть $G = (I, J)$ и стоит задача: найти все пути максимальных длины от первой до последней вершины ($1 \to n$).

Задача состоит в том, чтобы идти от $1$-ой вершины к вершине $n$ по всем возможным путям, а затем выбрать все пути с наибольшей длиной.

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=2]
		\node[vertex, fill=blue] (1) at (-3,0) {};
		\node[vertex, fill=blue] (11) at (2.2,0) {};
		\node[vertex] (2) at (-2, 0) {};
		\node[vertex, label=right:$\dots$] (3) at (-1.6, 0.6) {};
		\node[vertex, label=right:$\dots$] (4) at (-1.6, -0.6) {};
		\node[vertex] (5) at (-1, 0) {};
		\node[vertex, label=right:$\dots$] (6) at (-0.6, 0.6) {};
		\node[vertex] (7) at (-0.6, -0.6) {};
		\node[vertex] (8) at (0, 0) {};
		\node[vertex, label=right:$\dots$] (9) at (0.6, 0) {};
		\node[vertex, label=left:$\dots$] (10) at (1.6, 0) {};
		\draw[->, edge] (1) -- node[left] {} (2);
		\draw[->, edge] (2) -- node[left] {} (3);
		\draw[->, edge] (2) -- node[left] {} (4);
		\draw[->, edge] (2) -- node[left] {} (5);
		\draw[->, edge] (5) -- node[left] {} (6);
		\draw[->, edge] (5) -- node[left] {} (7);
		\draw[->, edge] (7) -- node[left] {} (8);
		\draw[->, edge] (8) -- node[left] {} (9);
		\draw[->, edge] (10) -- node[left] {} (11);
		\draw[->, edge] (1) to[bend left=60] (11);
		\draw[->, edge] (1) to[bend right=60] (11);
	\end{tikzpicture}
\end{figure}

Для этого будем использовать динамическое программирование. Поскольку нам не задано количество шагов (длины путей зависят от конкретной сети), то будем использовать \hyperref[alg:unknown_step_process]{многошаговый процесс принятия решений}. Вспомним, что по определению сети на множестве вершин определён строгий частичный порядок, что соответствует требования многошагового процесса (<<согласованность>> функции перехода).

\textbf{Выбор оптимальной стратегии}

Формализуем задачу поиска максимальных путей в терминах динамического программирования:

\begin{itemize}[nosep]
	\item \underline{состояние} на каждом шаге --- $i \in I$, то есть текущая вершина;
	
	\item \underline{решение} --- $j \in J$, то есть дуга, по которой мы пойдём;
	
	\item \underline{множество возможных состояний} --- $P = I$;
	
	\item \underline{множество конечных состояний} --- $\bar{P} = \{n\}$;
	
	\item \underline{начальное состояние} --- $p_0 = 1$;
	
	\item \underline{множество возможных решений} --- $Q = J$;
	
	\item \underline{множество допустимых решений}
	\[
	Q(i) = \{j \; \bigg| \; i(j) = i\}
	\]
	
	то есть это множество всех дуг, по которым можно пойти из вершины $i$;
	
	\item \underline{функция перехода} --- $T(i, j) = k(j)$, то есть мы находимся в вершине $i$ и двигаемся по дуге $j$;
	
	\item \underline{функция дохода} --- $g(i, j) = \tau_j$.
\end{itemize}

\textbf{База процесса}

Пусть $f(i)$ --- длина максимального пути из вершины $i$ в вершину $n$. По \hyperref[alg:unknown_step_process]{теории} $f(n) = 0$.

\textbf{Переход}

Пусть мы находимся в вершине $i$, тогда нам нужно рассмотреть все дуги, начинающиеся в данной вершине.

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=2]
		\node[vertex, label=left:$i$] (1) at (-3,0) {};
		\node[vertex] (2) at (-2.5,0) {};
		\node[vertex] (3) at (-2.6,0.4) {};
		\node[vertex] (4) at (-2.6,-0.4) {};
		
		\draw[->, edge] (1) -- node[left] {} (2);
		\draw[->, edge] (1) -- node[left] {} (3);
		\draw[->, edge] (1) -- node[left] {} (4);
	\end{tikzpicture}
\end{figure}

Таким образом,
\[
f(i) = \max_{j: \; i(j) = i} \Big\{\tau_j + f\big(k(j)\big)\Big\}.
\]

Так как $k(j) > 1$, то значение $f\big(k(j)\big)$ нам известно.

\textbf{Выбор стратегии}

Будем всё записывать в следующую таблицу

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c |} 
		\hline
		$i$ & $f(i)$ & $j(i)$\\ 
		\hline
		$1$ &&\\\hline
		$2$ && \\\hline
		$\dots$ && \\\hline
		$n-1$ && \\\hline
		$n$ && \\\hline
	\end{tabular}
\end{table}

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=2]
		\node[vertex, fill=blue, label=left:{$i=1$}] (1) at (-3,0) {};
		\node[vertex, fill=blue, label=right:{$i=n$}] (11) at (2.2,0) {};
		\node[vertex] (2) at (-2, 0) {};
		\node[vertex, label=right:$\dots$] (3) at (-1.6, 0.6) {};
		\node[vertex, label=right:$\dots$] (4) at (-1.6, -0.6) {};
		\node[vertex] (5) at (-1, 0) {};
		\node[vertex, label=right:$\dots$] (6) at (-0.6, 0.6) {};
		\node[vertex] (7) at (-0.6, -0.6) {};
		\node[vertex] (8) at (0, 0) {};
		\node[vertex, label=right:$\dots$] (9) at (0.6, 0) {};
		\node[vertex, label=left:$\dots$] (10) at (1.6, 0) {};
		\draw[->, edge, thick, red] (1) -- node[above] {$j(1)$} (2);
		\draw[->, edge] (2) -- node[left] {} (3);
		\draw[->, edge] (2) -- node[left] {} (4);
		\draw[->, edge, thick, red] (2) -- node[above] {$j(2)$} (5);
		\draw[->, edge] (5) -- node[left] {} (6);
		\draw[->, edge, thick, red] (5) -- node[left] {$j(3)$} (7);
		\draw[->, edge, thick, red] (7) -- node[below right] {$j(4)$} (8);
		\draw[->, edge, thick, red] (8) -- node[above]{$j(5)$} (9);
		\draw[->, edge, thick, red] (10) -- node[above] {$j(n-1)$} (11);
		\draw[->, edge] (1) to[bend left=60] (11);
		\draw[->, edge] (1) to[bend right=60] (11);
	\end{tikzpicture}
	\caption{Пример оптимальной стратегии}
\end{figure}

\remark

По ходу процесса, мы узнаем длины наибольших путей из каждой вершины в $n$-ую. Однако на будущее хотелось бы знать про максимальные пути из $1$-ой вершины в любую.

\algorithm[пути из $1$-ой вершины]

Для нахождения максимальных путей из $1$-ой вершины в любую другую проделаем тот же самый процесс, но будем идти не $1 \to n$, а $n \to 1$.

\textbf{База процесса}

Пусть $g(i)$ --- длина максимального пути из вершины $i$ в вершину $1$. По \hyperref[alg:unknown_step_process]{теории} $g(1) = 0$.

\textbf{Переход}

Запишем рекуррентное соотношение аналогично (чему?)

\[
g(i) = \max_{j': \; k(j') = i} \Big\{\tau_{j'} + g\big(i(j')\big)\Big\}.
\]

Вспомним, что $i(j') < i$, поэтому каждый раз мы будем переходить в вершину с меньшим номером, значит $g\big(i(j')\big)$ нам будет уже известно.

Итого, у нас будет таблица

Будем всё записывать в следующую таблицу

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c | c | c| } 
		\hline
		$i$ & $f(i)$ & $j(i)$ & $g(i)$ & $j'(i)$ \\ 
		\hline
		$1$ &&&&\\\hline
		$2$ &&&& \\\hline
		$\dots$ &&&& \\\hline
		$n-1$ &&&& \\\hline
		$n$ &&&& \\\hline
	\end{tabular}
\end{table}

Ясно, что $f(1) = g(n)$.

\remark

Пусть исходная сеть соответствовала некоторому проекту с набором работ $J$ и продолжительностями работ $\{\tau_j\}$. Проект будет реализован, если будут реализованы самые длинны пути $1 \to n$.

\definition

Длину максимального пути из первой вершины в $i$-ую будем обозначать $T_i^{\text{р}}$. В рамках проекта, это означает самое ранее время наступления события $i$.

\definition

\definitionfont{Критическим временем проекта} будет называть $T = T_n^{\text{р}} = g(n) = f(1)$.

\definition

Путь будем называть \definitionfont{критическим}, если его длина равняется $T$.

\definition

Работу будем называться \definitionfont{критической}, если дуга, соответствующая этой работе, входит в состав критического пути.

\remark

Если увеличить время критической работы, то время проекта увеличится.

\definition

\definitionfont{Наиболее поздним временем наступления события $i$} будем называть $T_i^{\text{П}} = T - f(i)$.

\remark

Мы уже говорили, что если работа критическая, то увеличивать её время нежелательно, так как увеличится время всего проекта. А если работа не критическая, то можно увеличить её время? И если можно, то насколько? Обозначим увеличение времени работы как $\delta_j$.

\fact

Максимальное значение $\Delta_j$, которое не приведёт к увеличению времени проекта вычисляется по формуле
\[
\Delta_j = T_{k(j)}^{\text{П}} - T_{i(j)}^{\text{р}} - \tau_j.
\]

\prooof

Заметим, что
\[
g\big(i(j)\big) + \tau_j + f\big(k(j)\big) \le T.
\]

Значит, к левой части можно добавить $\Delta_j$ так, чтобы левая часть не превысила $T$. А максимальное значение $\Delta_j$, которое можно добавить, это значение, при котором будет достигаться равенство, то есть

\[
g\big(i(j)\big) + \tau_j + \Delta_j + f\big(k(j)\big) = T,
\]
\[
\Updownarrow
\]
\begin{align*}
	\Delta_j =& \; T - 	f\big(k(j)\big) - g\big(i(j)\big) - \tau_j \\
	=& \; T_{k(j)}^{\text{П}} - T_{i(j)}^{\text{р}} - \tau_j.
\end{align*}

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=2]
		\node[vertex, fill=blue, label=left:{$i=1$}] (1) at (-3,0) {};
		\node[vertex] (2) at (-2.55,0.45) {};
		\node[vertex, label=left:{$\dots$}] (3) at (-2.45,0.55) {};
		\node[vertex, label=above:{$i(j)$}] (4) at (-2,1) {};
		\node[vertex, label=above:{$k(j)$}] (5) at (0,1) {};
		\node[vertex, label=right:{$\dots$}] (6) at (0.45,0.55) {};
		\node[vertex] (7) at (0.55,0.45) {};
		\node[vertex, fill=blue, label=right:{$i=n$}] (8) at (1,0) {};
		\node at (-1,1.3) {$\tau_j + \Delta_j$};
		\draw[->, edge] (1) to[bend left=15] (2);
		\draw[->, edge] (3) to[bend left=15] (4);
		\draw[->, edge] (4) to[bend left=15] (5);
		\draw[->, edge] (5) to[bend left=15] (6);
		\draw[->, edge] (7) to[bend left=15] (8);
		\draw [<->] (-3.5, 0.5) -- node[above left = -1mm] {$g\big(i(j)\big)$} (-2.5, 1.5);
		
		\draw [<->] (1.5, 0.5) -- node[above right = -1mm] {$f\big(k(j)\big)$} (0.5, 1.5);
	\end{tikzpicture}
\end{figure}

\implication

\begin{itemize}[nosep]
	\item[]
	
	\item Если $\Delta_j > T_{k(j)}^{\text{П}} - T_{i(j)}^{\text{р}} - \tau_j$, то время проекта увеличится;
	
	\item Если $\Delta_j < \dots$, то время проекта не изменится.
\end{itemize}

\section{Задача о максимальном потоке}

\definition

Пусть
\begin{itemize}[nosep]
	\item $G = (I, J)$ --- взвешенная сеть;
	
	\item $i = 1$ --- вход, $i = n$ --- выход;
	
	\item $b_{ik}$ --- вес дуги $\vec{ik}$;
\end{itemize}

тогда $x = (x_{ik})$ будем называть \definitionfont{потоком в сети} с величиной входного потока $v$, если выполняется следующие ограничения
\[
\forall l \in I \quad \sum_{k:\;(l, k) \in J} x_{lk} - \sum_{i: \; (i, l) \in J} x_{il} = \begin{cases}
	v, & l = 1, \\
	0, & l = 2 \dots n-1, \\
	-v, & l = n;
\end{cases}
\]

(закон сохранения энергии)

\[
\forall j = (i, k) \quad x_{ik} \le b_{ik}.
\]

\definition

\definitionfont{Величину потока $x$ в сети} будем обозначать $v(x)$.

\definition

Пару $(S, \bar{S})$ будем называть \definitionfont{разрезом сети}, если $S$ и $\bar{S}$ разбивают множество вершин сети, при этом обязательно $1 \in S$, $n \in \bar{S}$.

\definition

\definitionfont{Пропускной способностью разреза} будем называть
\[
B(S, \bar{S}) = \sum_{\underset{i \in S, k \in \bar{S}}{(i, k) \in J}} b_{ik}
\]

По сути, это сумма пропускным способностей всех дуг, идущих из $S$ в $\bar{S}$.

\fact[свойство разреза]

Какой бы ни был поток $x = (x_{ik})$ и разрез $(S, \bar{S})$
\[
v(x) \le B(S, \bar{S}).
\]

\prooof

Напишем следующие выражение
\[
Z = \sum_{l \in S} \bigg(\sum_{k:\;(l, k) \in J} x_{lk} - \sum_{i: \; (i, l) \in J} x_{il}\bigg).
\]

Вспомним, что по определению разреза $1 \in S$, а значит $Z = v + \dots$. Также вспомним определение потока и условия оттуда, из них следует, что внутреннее выражение для всех $l \neq 1$ равняется $0$. Из всего этого следует, что
\[
Z = \underbrace{0}_{v = 1} + \underbrace{0 + \dots + 0}_{1 \neq l \in S} = v
\]

Посмотрим на $Z$ с другой стороны. Рассмотрим возможные случаи взаимного расположения вершин $i$ и $k$ для вершины $l$

\begin{itemize}[nosep]
	\item $i \in S, k \in S$;
	
	\item $i \in S, k \in \bar{S}$;
	
	\item $k \in S, k \in S$.
\end{itemize}

\begin{align*}
	Z =& \; \sum_{l \in S} \bigg(\sum_{k:\;(l, k) \in J} x_{lk} - \sum_{i: \; (i, l) \in J} x_{il}\bigg) \\
	=& \;  \sum_{\underset{i \in S, k \in \bar{S}}{(i, k) \in J}} x_{ik} - \sum_{\underset{i \in \bar{S}, k \in S}{(i, k) \in J}} x_{ik} \\
	\le& \; \sum_{\underset{i \in S, k \in \bar{S}}{(i, k) \in J}} x_{ik} \\
	\le& \sum_{\underset{i \in S, k \in \bar{S}}{(i, k) \in J}} b_{ik} \\
	=& \; B(S, \bar{S}).
\end{align*}

Для перехода $\sum_{\dots}x_{ik} \le \sum_{\dots} b_{ik}$ использовалось условие из определения потока в сети.

Таким образом $Z = v$ и $Z \le B(S, \bar{S})$, значит $v \le B(S, \bar{S})$.

TODO: есть путаница, где-то просто $v$, а где-то $v(x)$.

\fact[критерий максимальности потока]
