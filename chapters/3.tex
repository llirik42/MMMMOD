\chapter{Сетевые модели}

\section{Теория графов}

\definition

\definitionfont{Графом} называется пара множеств $G = (V, E)$, где

\begin{itemize}[nosep]
	\item $V$ --- \definitionfont{множество вершин},
	
	\item $E \subseteq V \times V$ --- \definitionfont{множество рёбер}. 
\end{itemize}

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=1.5]
		\node[vertex, label=above:$v_1$] (v1) at (0,0) {};
		\node[vertex, label=left:$v_2$] (v2) at (-1,-1) {};
		\node[vertex, label=right:$v_3$] (v3) at (-1,-3) {};
		\node[vertex, label=above:$v_4$] (v4) at (0.5,-1.5) {};
		\node[vertex, label=right:$v_5$] (v5) at (1.5,-2.5) {};
	
		\draw[edge] (v1) -- node[left] {$e_1$} (v2);
		\draw[edge] (v2) -- node[left] {$e_3$} (v3);
		\draw[edge] (v2) -- node[above] {$e_2$} (v4);
		\draw[edge] (v4) -- node[above] {$e_4$} (v5);
	\end{tikzpicture}
	\caption{Пример графа}
\end{figure}

\definition

Вершины называются \definitionfont{смежными}, если они соединены ребром.

\definition

\definitionfont{Ориентированным графом} называется пара множеств $G = (V, E)$, где

\begin{itemize}[nosep]
	\item $V$ --- \definitionfont{множество вершин},
	
	\item $E \subseteq V \times V$ --- \definitionfont{множество дуг}.
\end{itemize}

Будем обозначать дугу от вершины $x$ до вершины $y$ как $\vec{xy}$.

\remark

В неориентированном графе если множество рёбер $E$ содержит ребро $(v_i, v_j)$, то оно также содержит ребро $(v_j, v_i)$. Сказать то же самое про дуги ориентированного графа нельзя.

\remark

В дальнейшем для простоты будем считать, что

\begin{itemize}[nosep]
	\item $V = \{1, 2, \dots, n\}$,
	
	\item $E = \{1, 2, \dots, m\}$.
\end{itemize}

\definition

Пусть каждая дуга $j$ ориентированного графа имеет некоторый вес $c(j)$, тогда \definitionfont{табличным видом ориентированного графа} будем называть следующую таблицу

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c | c | } 
		\hline
		$j$ & $i(j)$ & $k(j)$ & $c(j)$ \\ \hline
		$1$ &&& \\ \hline
		$1$ &&& \\ \hline
		$\dots$ &&&\\\hline
		$m$ &&& \\ \hline
	\end{tabular}
\end{table}

\begin{itemize}[nosep]
	\item $j$ --- дуга,
	
	\item $i(j)$ --- начальная точка дуги,
	
	\item $k(j)$ --- конечная точка дуги,
	
	\item $c(j)$ --- вес дуги.
\end{itemize}

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=1.5]
		\node[vertex, label=above:$i(j)$] (i) at (-1,-1) {};
		\node[vertex, label=left:$k(j)$] (k) at (1,1) {};
		
		\draw[->, edge] (i) -- node[left] {$j$} (k);
	\end{tikzpicture}
	\caption{Пример дуги $j$}
\end{figure}

\definition

\definitionfont{Путь} в графе от вершины $i_1$ до $i_k$ --- последовательность неповторяющихся вершин. Будем обозначать это как $p(i_1, \dots, i_k)$ или $\{i_1, \dots, i_k\}$, где $(i_l, i_{l+1}) \in E$.

\remark

В рамках данного курса не будут рассматриваться циклы пути, являющиеся циклами, то есть всегда $i_1 \neq i_k$.

\definition

\definitionfont{Сеть} --- ориентированных граф $G = (V, E)$, в котором

\begin{itemize}[nosep]
	\item есть 2 выделенные вершины $s$ (источник/вход) и $t$ (сток/выход);
	
	\item на множестве вершин есть строгий порядок.
\end{itemize}

Вершины $s$ и $t$ определяется так: $s$ --- наименьшая вершина, в которую не входит дуга; а $t$ --- наибольшая вершина, из которой не выходит дуга.

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=1.5]
		\node[vertex, label=left:\textcolor{blue}{$s$}, fill=blue] (s) at (-3,0) {};
		\node[vertex, label=right:\textcolor{blue}{$t$}, fill=blue] (t) at (1,0) {};
		\node[vertex] (v1) at (-1.6, -0.2) {};
		\node[vertex] (v2) at (-0.5, -0.6) {};
		\node[vertex] (v3) at (-0.9, 0.5) {};
		\node[vertex] (v4) at (-0.5, 1) {};
		
		\draw[->, edge] (s) -- node[left] {} (v1);
		\draw[->, edge] (v1) -- node[left] {} (v2);
		\draw[->, edge] (v1) -- node[left] {} (v3);
		\draw[->, edge] (v3) -- node[left] {} (t);
		\draw[->, edge] (v2) -- node[left] {} (t);
		\draw[->, edge] (v3) -- node[left] {} (v4);
		\draw[->, edge] (s) to[bend left=60] (t);
		\draw[->, edge] (s) to[bend right=60] (t);
	\end{tikzpicture}
	\caption{Пример сети}
\end{figure}

\section{Сетевая модель проекта}

\definition

\definitionfont{Модель проекта} определяется следующим образом:

\begin{itemize}[nosep]
	\item $J = \{1, \dots, n\}$ --- множество работ проекта,
	
	\item $\tau_{j} \ge 0$ --- длительность работы $j$;
	
	\item $C = \big\{(i, j) \; \big| \; i,j \in J\big\}$ --- частичный порядок, работа $j$ не может начаться раньше окончанию работы $i$.
\end{itemize}

Модель проекта можно записать с помощью следующей таблицы

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c | } 
		\hline
		$j$ & \text{следующие работы} & $\tau_j$ \\ \hline
		$j_0$ & $j_1$, $j_2$, $\dots$ & $\tau_{j_0}$ \\ \hline
		$\dots$ & $\dots$ & $\dots$ \\ \hline
	\end{tabular}
\end{table}

\example

Рассмотрим следующую модель проекта:

\begin{itemize}[nosep]
	\item $\mathbf{J} = \{A, B, C, D, E, F, G, H, I, J\}$ --- множество работ проекта,
	
	\item $A$ --- выбрать место для офиса,
	
	\item $B$ --- создать финансовый и организационный план,
	
	\item $C$ --- определить обязанности персонала,
	
	\item $D$ --- разработать план офиса,
	
	\item $E$ --- ремонт помещений,
	
	\item $F$ --- отобрать кандидатов на увольнение,
	
	\item $G$ --- нанять новых служащих,
	
	\item $H$ --- назначить ключевых руководителей,
	
	\item $I$ --- распределить обязанности руководителей,
	
	\item $J$ --- обучить персонал;
\end{itemize}

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c | } 
		\hline
		$j$ & \text{следующие работы} & $\tau_j$ \\ \hline
		$A$ & $\{D\}$ & $3$ \\ \hline
		$B$ & $\{C, I\}$ & $5$ \\ \hline
		$C$ & $\{D, F\}$ & $3$ \\ \hline
		$D$ & $\{E\}$ & $5$ \\ \hline
		$E$ & $\{J\}$ & $10$ \\ \hline
		$F$ & $\{G, H\}$ & $2$ \\ \hline
		$G$ & $\{J\}$ & $5$ \\ \hline
		$H$ & $\{J\}$ & $2$ \\ \hline
		$I$ & $\{\}$ & $5$ \\ \hline
		$J$ & $\{\}$ & $3$ \\ \hline
	\end{tabular}
\end{table}

\definition

\definitionfont{Сетевая модель проекта} --- наглядное представление работ в виде сети, в которой для каждой работы есть дуга, а отношение следования работ в проекте имеет место и в сети.

\definitionfont{Сетевая модель проекта} --- ориентированный взвешенный граф без циклов $G = (V, E)$ с выделенными вершинами $s$ и $t$, при этом каждой дуге $j = \vec{ik}$ приписан вес $\tau_j \ge 0$. Вершинами сети будут \definitionfont{события} (результаты выполнения работ), а дугами сами работы.

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=1.5]
		\node[vertex, label=left:\textcolor{blue}{$s$}, fill=blue] (s) at (-3,0) {};
		\node[vertex, label=right:\textcolor{blue}{$t$}, fill=blue] (t) at (2,-1) {};
		\node[vertex] (sa) at (-2.3,0.7) {};
		\node[vertex] (sb) at (-2.3,-0.7) {};
		\node[vertex] (ad) at (-0.8,0.7) {};
		\node[vertex] (de) at (0.7,0.7) {};
		\node[vertex] (bci) at (-0.8,-0.7) {};
		\node[vertex] (fgh) at (0.7,-0.7) {};
		
		\node at (0.4,0) {$G$};
		\node at (1,0) {$H$};
		\node at (1.7, -0.1) {$J$};
		\node at (-1, -1.2) {$I$};
		\draw[->, edge] (s) -- node[above left] {$A$} (sa);
		\draw[->, edge] (s) -- node[below left] {$B$} (sb);
		\draw[->, edge] (sa) -- node[above] {$D$} (ad);
		\draw[->, edge] (ad) -- node[above] {$E$} (de);
		\draw[->, edge] (fgh) to[bend left=20] (de);
		\draw[->, edge] (fgh) to[bend right=20] (de);
		\draw[->, edge] (sb) -- node[above] {$C$} (bci);
		\draw[->, edge] (bci) -- node[above] {$F$} (fgh);
		\draw[->, edge, dashed] (bci) -- node[above] {} (sa);
		\draw[->, edge] (sb) to[bend right=10] (t);
		\draw[->, edge] (de) to[bend left=10] (t);
	\end{tikzpicture}
	\caption{Сеть для проекта из примера}
\end{figure}

\algorithm[построения сетевой модели]

\begin{enumerate}[nosep]
	\item[]
	
	\item Для каждой работы строим вершины и дуги.
	
	\item Рисуем фиктивные дуги из конца текущей работы в следующую.
	
	\item Ставим начальную и конечную вершины $s$ и $t$.
	
	\item Убираем фиктивные дуги, если она единственная, которая входит или выходит и если она не создаёт параллельные соединения.
\end{enumerate}

\fact

Нумерация вершин в сети верна тогда и только тогда, когда номер предыдущей вершины меньше номера следующей.

\definition

\definitionfont{Рангом} $r(x)$ вершины $x \in V$ называется число дуг в максимальном пути (по числу дуг) из источника $s$ в вершину $x$. \definitionfont{Рангом проекта} $R$ называется $r(t)$ (ранг стока/выхода).

\algorithm[Форда]

\fact

Алгоритм Форда создаёт корректную нумерацию вершин в сети.
