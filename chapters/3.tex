\chapter{Сетевые модели}

\section{Теория графов}

\definition

\definitionfont{Графом} называется пара множеств $G = (V, E)$, где

\begin{itemize}[nosep]
	\item $V$ --- \definitionfont{множество вершин},
	
	\item $E \subseteq V \times V$ --- \definitionfont{множество рёбер}. 
\end{itemize}

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=1.5]
		\node[vertex, label=above:$v_1$] (v1) at (0,0) {};
		\node[vertex, label=left:$v_2$] (v2) at (-1,-1) {};
		\node[vertex, label=right:$v_3$] (v3) at (-1,-3) {};
		\node[vertex, label=above:$v_4$] (v4) at (0.5,-1.5) {};
		\node[vertex, label=right:$v_5$] (v5) at (1.5,-2.5) {};
	
		\draw (v1) -- node[left] {$e_1$} (v2);
		\draw (v2) -- node[left] {$e_3$} (v3);
		\draw (v2) -- node[above] {$e_2$} (v4);
		\draw (v4) -- node[above] {$e_4$} (v5);
	\end{tikzpicture}
	\caption{Пример графа}
\end{figure}

\definition

Вершины называются \definitionfont{смежными}, если они соединены ребром.

\definition

\definitionfont{Ориентированным графом} называется пара множеств $G = (V, E)$, где

\begin{itemize}[nosep]
	\item $V$ --- \definitionfont{множество вершин},
	
	\item $E \subseteq V \times V$ --- \definitionfont{множество дуг}.
\end{itemize}

Будем обозначать дугу от вершины $x$ до вершины $y$ как $\vec{xy}$.

\remark

В неориентированном графе если множество рёбер $E$ содержит ребро $(v_i, v_j)$, то оно также содержит ребро $(v_j, v_i)$. Гарантировать то же самое в ориентированном графе нельзя.

\remark

В дальнейшем для простоты будем считать, что

\begin{itemize}[nosep]
	\item $V = \{1, 2, \dots, n\}$,
	
	\item $E = \{1, 2, \dots, m\}$.
\end{itemize}

\definition

Пусть каждая дуга $j$ ориентированного графа имеет некоторый вес $c(j)$, тогда \definitionfont{табличным видом ориентированного графа} будем называть следующую таблицу

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c | c | } 
		\hline
		$j$ & $i(j)$ & $k(j)$ & $c(j)$ \\ \hline
		$1$ &&& \\ \hline
		$1$ &&& \\ \hline
		$\dots$ &&&\\\hline
		$m$ &&& \\ \hline
	\end{tabular}
\end{table}

\begin{itemize}[nosep]
	\item $j$ --- дуга,
	
	\item $i(j)$ --- начальная точка дуги,
	
	\item $k(j)$ --- конечная точка дуги,
	
	\item $c(j)$ --- вес дуги.
\end{itemize}

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=1.5]
		\node[vertex, label=above:$i(j)$] (i) at (-1,-1) {};
		\node[vertex, label=left:$k(j)$] (k) at (1,1) {};
		
		\draw[->, edge] (i) -- node[left] {$j$} (k);
	\end{tikzpicture}
	\caption{Пример дуги $j$}
\end{figure}

\definition

\definitionfont{Путь} в графе от вершины $i_1$ до $i_{L+1}$ --- последовательность неповторяющихся вершин. Будем обозначать это как $P(i_1, \dots, i_{L+1})$ или $\{i_1, \dots, i_{L+1}\}$, где $(i_l, i_{l+1}) \in E$.

\remark

В рамках данного курса не будут рассматриваться пути, являющиеся циклами, то есть всегда $i_1 \neq i_k$.

\definition

\definitionfont{Сеть} --- ориентированных граф $G = (I, J)$, в котором

\begin{itemize}[nosep]
	\item есть 2 выделенные вершины $s$ (источник/вход) и $t$ (сток/выход);
	
	\item на множествах вершин и рёбер определён строгий порядок.
\end{itemize}

Вершины $s$ и $t$ определяется так: $s$ --- наименьшая вершина, в которую не входит дуга; а $t$ --- наибольшая вершина, из которой не выходит дуга.

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=1.5]
		\node[vertex, label=left:\textcolor{blue}{$s$}, fill=blue] (s) at (-3,0) {};
		\node[vertex, label=right:\textcolor{blue}{$t$}, fill=blue] (t) at (1,0) {};
		\node[vertex] (v1) at (-1.6, -0.2) {};
		\node[vertex] (v2) at (-0.5, -0.6) {};
		\node[vertex] (v3) at (-0.9, 0.5) {};
		\node[vertex] (v4) at (-0.5, 1) {};
		
		\draw[->, edge] (s) -- node[left] {} (v1);
		\draw[->, edge] (v1) -- node[left] {} (v2);
		\draw[->, edge] (v1) -- node[left] {} (v3);
		\draw[->, edge] (v3) -- node[left] {} (t);
		\draw[->, edge] (v2) -- node[left] {} (t);
		\draw[->, edge] (v3) -- node[left] {} (v4);
		\draw[->, edge] (s) to[bend left=60] (t);
		\draw[->, edge] (s) to[bend right=60] (t);
	\end{tikzpicture}
	\caption{Пример сети}
\end{figure}

\begin{definition}
	Сеть называется \definitionfont{взвешенной}, если у каждой дуги $j$ есть некоторой вес $\tau_j$. Тогда такую сеть можно задать с помощью следующей таблицы
	
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | c | c |} 
			\hline
			$j$ & $i(j)$ & $k(j)$ & $c(j)$ & $\tau_j$ \\ \hline
			$1$ &&&& \\ \hline
			$1$ &&&& \\ \hline
			$\dots$ &&&& \\\hline
			$m$ &&&& \\ \hline
		\end{tabular}
	\end{table}
\end{definition}

\section{Сетевая модель проекта}

\definition

\definitionfont{Проект} --- совокупность работ для достижения определённой цели. \definitionfont{Модель проекта} определяется следующим образом:

\begin{itemize}[nosep]
	\item $J = \{1, \dots, n\}$ --- множество работ проекта,
	
	\item $\tau_{j} \ge 0$ --- длительность работы $j$;
	
	\item $C = \big\{(i, j) \; \big| \; i,j \in J\big\}$ --- частичный порядок, работа $j$ не может начаться раньше окончанию работы $i$.
\end{itemize}

Модель проекта можно записать с помощью следующей таблицы

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c | } 
		\hline
		$j$ & \text{следующие работы} & $\tau_j$ \\ \hline
		$j_0$ & $j_1$, $j_2$, $\dots$ & $\tau_{j_0}$ \\ \hline
		$\dots$ & $\dots$ & $\dots$ \\ \hline
	\end{tabular}
\end{table}

При этом, <<следующие работы>> для работы $j$ --- это работы, которые зависят от $j$, то есть которые не могут начаться раньше, чем завершится работа $j$.

\example\label{ex:office_project}

Рассмотрим следующую модель проекта:

\begin{itemize}[nosep]
	\item $J = \{1, 2, \dots, 9, 10\}$ --- множество работ проекта,
	
	\item $1$ --- выбрать место для офиса,
	
	\item $2$ --- создать финансовый и организационный план,
	
	\item $3$ --- определить обязанности персонала,
	
	\item $4$ --- разработать план офиса,
	
	\item $5$ --- ремонт помещений,
	
	\item $6$ --- отобрать кандидатов на увольнение,
	
	\item $7$ --- нанять новых служащих,
	
	\item $8$ --- назначить ключевых руководителей,
	
	\item $9$ --- распределить обязанности руководителей,
	
	\item $10$ --- обучить персонал;
\end{itemize}

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c | } 
		\hline
		$j$ & \text{следующие работы} & $\tau_j$ \\ \hline
		$1$ & $\{4\}$ & $3$ \\ \hline
		$2$ & $\{3, 9\}$ & $5$ \\ \hline
		$3$ & $\{4, 6\}$ & $3$ \\ \hline
		$4$ & $\{5\}$ & $5$ \\ \hline
		$5$ & $\{10\}$ & $10$ \\ \hline
		$6$ & $\{7, 8\}$ & $2$ \\ \hline
		$7$ & $\{10\}$ & $5$ \\ \hline
		$8$ & $\{10\}$ & $2$ \\ \hline
		$9$ & $\O$ & $5$ \\ \hline
		$10$ & $\O$ & $3$ \\ \hline
	\end{tabular}
\end{table}

\definition

\definitionfont{Сетевая модель проекта} --- наглядное представление работ в виде сети, в которой для каждой работы есть дуга, а отношение следования работ в проекте имеет место и в сети.

\definitionfont{Сетевая модель проекта} --- ориентированный взвешенный граф без циклов $G = (V, E)$ с выделенными вершинами $s$ и $t$, при этом каждой дуге $j = \vec{ik}$ приписан вес $\tau_j \ge 0$. Вершинами сети будут \definitionfont{события} (результаты выполнения работ), а дугами сами работы.

\textbf{Обозначение}: \circled{1} --- вершина с номером $1$, \squared{1} --- дуга с номером $1$.

\example

Изобразим сетевую модель проекта из \hyperref[ex:office_project]{примера}.

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=2.2]
		\node[vertex, label=left:\textcolor{blue}{\circled{1}}, fill=blue] (1) at (-3,0) {};
		\node[vertex, label=right:\textcolor{blue}{\circled{9}}, fill=blue] (9) at (4,-1) {};
		\node[vertex, label={\circled{4}}] (4) at (-2.3,0.7) {};
		\node[vertex, label={\circled{2}}] (2) at (-2.3,-0.7) {};
		\node[vertex, label={\circled{5}}] (5) at (0,0.7) {};
		\node[vertex, label={\circled{8}}] (8) at (2.2,0.7) {};
		\node[vertex, label={\circled{3}}] (3) at (-0.8,-0.7) {};
		\node[vertex, label={\circled{6}}] (6) at (0.7,-0.7) {};
		\node[vertex] (7) at (2.2,-0.7) {};
		
		\node at (1.3,0.2) {\squared{7}};
		\node at (3.5, 0) {\squared{10}};
		\node at (2, -1.4) {\squared{9}};
		\node at (-1.4, 0.2) {\squared{11}};
		\node at (2.4, -0.6) {\circled{7}};
		\node at (2.45, 0.1) {\squared{12}};
		
		\draw[->, edge] (1) -- node[above left] {\squared{1}} (4);
		\draw[->, edge] (1) -- node[below left] {\squared{2}} (2);
		\draw[->, edge] (4) -- node[above] {\squared{4}} (5);
		\draw[->, edge] (5) -- node[above] {\squared{5}} (8);
		\draw[->, edge] (6) -- node[above] {} (8);
		\draw[->, edge] (6) -- node[above] {\squared{8}} (7);
		\draw[->, edge] (2) -- node[above] {\squared{3}} (3);
		\draw[->, edge] (3) -- node[above] {\squared{6}} (6);
		\draw[->, edge, dashed] (3) -- node {} (4);
		\draw[->, edge] (2) to[bend right=10] (9);
		\draw[->, edge] (8) to[bend left=10] (9);
		\draw[->, edge, dashed] (7) -- node[above] {} (8);
	\end{tikzpicture}
	\caption{Сеть для проекта из примера. Дуги $11$ и $12$ является фиктивными, то есть не соответствуют работам из модели проекта, они нужны для целостности сети.}
\end{figure}

\algorithm[построения сетевой модели]\label{alg:building_network_model}

\begin{enumerate}[nosep]
	\item[]
	
	\item Для каждой работы строим вершины и дуги.
	
	\item Обозначаем подчинённость, рисуя фиктивные дуги из конца текущей работы в следующую в соответствии с проектом.
	
	\item Добавляем начальную и конечную вершины $s$ и $t$.
	
	\item Убираем фиктивные дуги так, чтобы граф не перестал быть сетью, а также чтобы не появились параллельные дуги. Фиктивную дугу можно убрать, если она единственная, которая входит в вершину или выходит из вершины.
	
	\item Пронумеровываем вершины сети так, чтобы для каждой дуги $j$ выполнялось $i(j) < k(j)$.
\end{enumerate}

\subsection{Алгоритм Форда}

\definition

\definitionfont{Рангом} $r(x)$ вершины $x \in V$ называется число дуг в максимальном (по числу дуг) пути из начальной вершины $s$ в вершину $x$. \definitionfont{Рангом проекта} называется $r(t)$ (ранг стока/выхода/конечной вершины).

\algorithm[Форда]\label{alg:ford}

Алгоритм позволяет устанавливать ранги в сети так, чтобы нумерация вершин оказалось корректной с точки зрения условия $i(j) < k(j)$.

Алгоритм включает в себя две стадии: вычисление рангов вершин, нумерация вершин по их рангам; $r_k$ --- ранг вершины $k$.

\bigskip

\textbf{Вычисление рангов}
\begin{enumerate}[nosep]
	\item Инициализируем все $r_k = 0$;
	
	\item Последовательно просматриваем все работы сверху вниз по таблице ($j = \vec{ik}$ --- текущая работа) и меняем ранг:
	\[
	r_k = \max\{r_k, r_i+1\};
	\]
	
	\item Если все ранги на текущей итерации совпадают с рангами на прошлой, то завершаем алгоритм, иначе --- переходим к следующей итерации (шаг 2).
\end{enumerate}

\begin{note}
	Ранги удобно записывать в таблицу
	
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | c | c | } 
			\hline
			$k$ & $r_k^0$ & $r_k^1$ & $r_k^2$ & $\dots$ \\\hline
			$1$ & $0$ & $\dots$ & $\dots$ & $\dots$ \\\hline
			$2$ & $0$ & $\dots$ & $\dots$ & $\dots$ \\\hline
			$\dots$ & $\dots$ & $\dots$ & $\dots$ & $\dots$ \\\hline
			$n$ & $0$ & $\dots$ & $\dots$ & $\dots$ \\\hline
		\end{tabular}
	\end{table}
	
	где $r_k^i$ --- ранг вершины $k$ на $i$-ой итерации, при этом перед каждой итерацией $i$
	\[
	r_k^i = r_k^{i-1}.
	\]
\end{note}

\bigskip

\textbf{Нумерация вершин}

\begin{enumerate}[nosep]
	\item Инициализируем $r = 0$ --- ранг, $N = 1$ --- номер вершины;
	
	\item Выбираем первую вершину с рангом $r$, присваиваем ей номер $N$ и инкрементируем $N$; если вершин с рангом $r$ больше не осталось, то записываем в $r$ следующий по возрастанию ранг из таблицы и повторяем шаг.
\end{enumerate}

\remark

Значение $r_k$ для одной и той же вершины $k$ может меняться несколько раз в течение одного шага.

\remark

Если сеть относительно небольшая, то быстрее будет <<вручную>> пронумеровать вершины, а не пользоваться алгоритмом Форда.

\fact

Алгоритм Форда создаёт корректную нумерацию вершин в сети.

\section{Практика построения сетей и нумерации вершин}

\subsection{Проект постройки дома}
\project[постройки дома]\label{proj:house_building_project}

\textbf{Исходные данные}

Имеется проект постройки дома состоящий из восьми работ, необходимо построить сетевую модель проекта с корректной нумерацией вершин. Список работ:

\begin{enumerate}[nosep]
	\item очистка участка,
	\item земляные работы под фундамент,
	\item прокладка наружных коммуникаций,
	\item заливка фундамента и возведение стен,
	\item устройство крыши,
	\item прокладка внутренних коммуникаций,
	\item внутренние отделочные работы,
	\item обустройство территории.
\end{enumerate}

\bigskip

\textbf{Таблица работ}

Для удобства дальнейшей работы изобразим модель проекта в виде таблицы

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | } 
		\hline
		j & следующие работы \\\hline
		$1$ & $\{2,3\}$ \\\hline
		$2$ & $\{4\}$ \\\hline
		$3$ & $\{8,6\}$ \\\hline
		$4$ & $\{5,6\}$ \\\hline
		$5$ & $\O$ \\\hline
		$6$ & $\{7\}$ \\\hline
		$7$ & $\O$ \\\hline
		$8$ & $\O$ \\\hline
	\end{tabular}
\end{table}

\bigskip

\textbf{Построение сетевой модели}

Будем использовать \hyperref[alg:building_network_model]{алгоритм построения сетевой модели}.

\begin{itemize}[nosep]
	\item[\fbox{Шаг 1}] Построение вершин и дуг для каждой работы

	\begin{figure}[H]
		\centering	
		\begin{tikzpicture}[scale=2.2]
			\node[vertex] (1) at (-3,0) {};
			\node[vertex] (2) at (-2,0) {};
			\node[vertex] (3) at (-3,-1) {};
			\node[vertex] (4) at (-2,-1) {};
			\node[vertex] (5) at (-1,0) {};
			\node[vertex] (6) at (0,0) {};
			\node[vertex] (7) at (-2,-2) {};
			\node[vertex] (8) at (-1, -2) {};
			\node[vertex] (9) at (0,-2) {};
			\node[vertex] (10) at (1, -2) {};
			\node[vertex] (11) at (0,-1) {};
			\node[vertex] (12) at (1, -1) {};
			\node[vertex] (13) at (2,-1) {};
			\node[vertex] (14) at (3, -1) {};
			\node[vertex] (15) at (1,0) {};
			\node[vertex] (16) at (2,0) {};
			
			\draw[->, edge] (1) -- node[above] {\squared{1}} (2);
			\draw[->, edge] (3) -- node[above] {\squared{2}} (4);
			\draw[->, edge] (5) -- node[above] {\squared{3}} (6);
			\draw[->, edge] (7) -- node[above] {\squared{4}} (8);
			\draw[->, edge] (9) -- node[above] {\squared{5}} (10);
			\draw[->, edge] (11) -- node[above] {\squared{6}} (12);
			\draw[->, edge] (13) -- node[above] {\squared{7}} (14);
			\draw[->, edge] (15) -- node[above] {\squared{8}} (16);
			
		\end{tikzpicture}
	\end{figure}
	
	\item[\fbox{Шаг 2}] Обозначение подчиненностей (по таблице модели проекта), добавление начальной и конечной вершин
	
	\begin{figure}[H]
		\centering	
		\begin{tikzpicture}[scale=2.2]
			\node[vertex, label=left:\textcolor{blue}{$s$}, fill=blue] (1) at (-4,0) {};
			\node[vertex] (2) at (-3,0) {};
			\node[vertex] (3) at (-3,-1) {};
			\node[vertex] (4) at (-2,-1) {};
			\node[vertex] (5) at (-1,0) {};
			\node[vertex] (6) at (0,0) {};
			\node[vertex] (7) at (-2,-2) {};
			\node[vertex] (8) at (-1, -2) {};
			\node[vertex] (9) at (0,-2) {};
			\node[vertex] (10) at (1, -2) {};
			\node[vertex] (11) at (0,-1) {};
			\node[vertex] (12) at (1, -1) {};
			\node[vertex] (13) at (2,-1) {};
			\node[vertex] (14) at (3, -1) {};
			\node[vertex] (15) at (1,0) {};
			\node[vertex] (16) at (2,0) {};
			\node[vertex, label=right:\textcolor{blue}{$t$}, fill=blue] (17) at (3.5,-1) {};
			
			\draw[->, edge] (1) -- node[above] {\squared{1}} (2);
			\draw[->, edge] (3) -- node[above] {\squared{2}} (4);
			\draw[->, edge] (5) -- node[above] {\squared{3}} (6);
			\draw[->, edge] (7) -- node[above] {\squared{4}} (8);
			\draw[->, edge] (9) -- node[above] {\squared{5}} (10);
			\draw[->, edge] (11) -- node[above] {\squared{6}} (12);
			\draw[->, edge] (13) -- node[above] {\squared{7}} (14);
			\draw[->, edge] (15) -- node[above] {\squared{8}} (16);
			
			\draw[->, edge, dashed] (2) -- node {} (3);
			\draw[->, edge, dashed] (2) -- node {} (5);
			\draw[->, edge, dashed] (4) -- node {} (7);
			\draw[->, edge, dashed] (8) -- node {} (9);
			\draw[->, edge, dashed] (6) -- node {} (11);
			\draw[->, edge, dashed] (6) -- node {} (15);
			\draw[->, edge, dashed] (12) -- node {} (13);
			\draw[->, edge, dashed] (8) -- node {} (11);
			\draw[->, edge, dashed] (10) -- node {} (17);
			\draw[->, edge, dashed] (14) -- node {} (17);
			\draw[->, edge, dashed] (16) -- node {} (17);
			
		\end{tikzpicture}
	\end{figure}
	
	\item[\fbox{Шаг 3}] Удаление фиктивных дуг
	
	\begin{figure}[H]
		\centering	
		\begin{tikzpicture}[scale=2.2]
			\node[vertex, label=left:\textcolor{blue}{$s$}, fill=blue] (1) at (-4,0) {};
			\node[vertex] (2) at (-3,0) {};
			\node[vertex] (3) at (-2,-1) {};
			\node[vertex] (4) at (0,0) {};
			\node[vertex] (5) at (-1, -2) {};
			\node[vertex] (6) at (0,-1) {};
			\node[vertex] (7) at (2,-1) {};
			\node[vertex, label=right:\textcolor{blue}{$t$}, fill=blue] (8) at (3.5,-1) {};
			
			\draw[->, edge] (1) -- node[above] {\squared{1}} (2);
			\draw[->, edge] (2) -- node {} (3);
			\draw[->, edge] (3) -- node {} (5);
			\draw[->, edge] (2) -- node[above] {\squared{3}} (4);
			\draw[->, edge] (6) -- node[above] {\squared{6}} (7);
			\draw[->, edge] (7) -- node {} (8);
			\draw[->, edge] (4) -- node[above] {\squared{8}} (8);
			\draw[->, edge] (5) -- node[above] {\squared{5}} (8);
			
			\draw[->, edge, dashed] (4) -- node {} (6);
			\draw[->, edge, dashed] (5) -- node {} (6);
			
			\node at (2.2, -0.8) {\squared{7}};
			\node at (-2.25, -0.5) {\squared{2}};
			\node at (-1.5, -1.25) {\squared{4}};
			
		\end{tikzpicture}
	\end{figure}
	
	\item[\fbox{Шаг 4}] Нумерация вершин. Пронумеруем вершины, стараясь сделать $i(j) < k(j)$.
	
	\begin{figure}[H]
		\centering	
		\begin{tikzpicture}[scale=2.2]
			\node[vertex, label={\circled{1}}, fill=blue] (1) at (-4,0) {};
			\node[vertex, label={\circled{2}}] (2) at (-3,0) {};
			\node[vertex, label={\circled{6}}] (3) at (-2,-1) {};
			\node[vertex, label={\circled{5}}] (4) at (0,0) {};
			\node[vertex, label={\circled{4}}] (5) at (-1, -2) {};
			\node[vertex, label=above right:\circled{3}] (6) at (0,-1) {};
			\node[vertex, label=\circled{8}] (7) at (2,-1) {};
			\node[vertex, label={\circled{7}}, fill=blue, fill=blue] (8) at (3.5,-1) {};
			
			\draw[->, edge] (1) -- node[above] {\squared{1}} (2);
			\draw[->, edge] (2) -- node {} (3);
			\draw[->, edge] (3) -- node {} (5);
			\draw[->, edge] (2) -- node[above] {\squared{3}} (4);
			\draw[->, edge] (6) -- node[above] {\squared{6}} (7);
			\draw[->, edge] (7) -- node {} (8);
			\draw[->, edge] (4) -- node[above] {\squared{8}} (8);
			\draw[->, edge] (5) -- node[above] {\squared{5}} (8);
			
			\draw[->, edge, dashed] (4) -- node {} (6);
			\draw[->, edge, dashed] (5) -- node {} (6);
			
			\node at (2.4, -0.85) {\squared{7}};
			\node at (-2.35, -0.4) {\squared{2}};
			\node at (-1.5, -1.25) {\squared{4}};
			\node at (0.2, -0.4) {\squared{10}};
			\node at (-0.6, -1.3) {\squared{9}};
			
		\end{tikzpicture}
	\end{figure}
	
	Составим табличный вид данной сети:
	
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | } 
			\hline
			$j$ & $i(j)$ & $k(j)$ \\ \hline
			
			$1$ & $1$ & $2$ \\ \hline
			$2$ & $2$ & $6$ \\ \hline
			$3$ & $2$ & $5$ \\ \hline
			$4$ & $6$ & $4$ \\ \hline
			$5$ & $4$ & $7$ \\ \hline
			$6$ & $3$ & $8$ \\ \hline
			$7$ & $8$ & $7$ \\ \hline
			$8$ & $5$ & $7$ \\ \hline
			$9$ & $4$ & $3$ \\ \hline
			$10$ & $5$ & $3$ \\ \hline
		\end{tabular}
	\end{table}
	
	Видно, что для $j \in \{4, 7, 9, 10\}$ \underline{не удалось корректно пронумеровать вершины} так как $i(j) > k(j)$.

\end{itemize}

\bigskip

\textbf{Нумерация вершин}

Воспользуемся \hyperref[alg:ford]{алгоритмом Форда}, чтобы определить ранги вершин и корректно их пронумеровать. Будем итеративно заполнять таблицу из алгоритма ($i$ --- номер итерации).

\begin{itemize}[nosep]
	\item[\fbox{$i=0$}] По алгоритму все $r_k^0 = 0$.

	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | } 
			\hline
			$k$ & $r_k^0$ \\ \hline
			$1$ & $0$ \\ \hline
			$2$ & $0$ \\ \hline
			$3$ & $0$ \\ \hline
			$4$ & $0$ \\ \hline
			$5$ & $0$ \\ \hline
			$6$ & $0$ \\ \hline
			$7$ & $0$ \\ \hline
			$8$ & $0$ \\ \hline
		\end{tabular}
	\end{table}

	\item[\fbox{$i=1$}] Следуя алгоритму, вычисляем $r^1_k$, используя табличный вид сети:

	\begin{enumerate}[nosep]
		\item[\underline{$j=1$}:] $r_2^1 = \max\{r_2^1, r_1^1 + 1\} = \max\{0,0+1\} = 1$
		\item[\underline{$j=2$}:] $r_6^1 = \max\{r_6^1, r_2^1 + 1\} = \max\{0,1+1\} = 2$
		\item[\underline{$j=3$}:] $r_5^1 = \max\{r_5^1, r_2^1 + 1\} = \max\{0,1+1\} = 2$
		\item[\underline{$j=4$}:] $r_4^1 = \max\{r_4^1, r_6^1 + 1\} = \max\{0,2+1\} = 3$
		\item[\underline{$j=5$}:] $r_7^1 = \max\{r_7^1, r_4^1 + 1\} = \max\{0,3+1\} = 4$
		\item[\underline{$j=6$}:] $r_8^1 = \max\{r_8^1, r_3^1 + 1\} = \max\{0,0+1\} = 1$
		\item[\underline{$j=7$}:] $r_7^1 = \max\{r_7^1, r_8^1 + 1\} = \max\{4,1+1\} = 4$
		\item[\underline{$j=8$}:] $r_7^1 = \max\{r_7^1, r_5^1 + 1\} = \max\{4,2+1\} = 4$
		\item[\underline{$j=9$}:] $r_3^1 = \max\{r_3^1, r_4^1 + 1\} = \max\{0,3+1\} = 4$
		\item[\underline{$j=10$}:] $r_3^1 = \max\{r_3^1, r_5^1 + 1\} = \max\{4,2+1\} = 4$
	\end{enumerate}

	\bigskip

	Запишем результаты в таблицу:
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | } 
			\hline
			$k$ & $r_k^0$ & $r_k^1$ \\ \hline
			$1$ & $0$ & $0$ \\ \hline
			$2$ & $0$ & $1$ \\ \hline
			$3$ & $0$ & $4$ \\ \hline
			$4$ & $0$ & $3$ \\ \hline
			$5$ & $0$ & $2$ \\ \hline
			$6$ & $0$ & $2$ \\ \hline
			$7$ & $0$ & $4$ \\ \hline
			$8$ & $0$ & $1$ \\ \hline
		\end{tabular}
	\end{table}

	\item[\fbox{$i=2$}] Следуя алгоритму, вычисляем $r^2_k$, используя табличный вид сети:

	\begin{enumerate}[nosep]
		\item[\underline{$j=1$}:] $r_2^2 = \max\{r_2^2, r_1^2 + 1\} = \max\{0,0+1\} = 1$
		\item[\underline{$j=2$}:] $r_6^2 = \max\{r_6^2, r_2^2 + 1\} = \max\{2,1+1\} = 2$
		\item[\underline{$j=3$}:] $r_5^2 = \max\{r_5^2, r_2^2 + 1\} = \max\{2,1+1\} = 2$
		\item[\underline{$j=4$}:] $r_4^2 = \max\{r_4^2, r_6^2 + 1\} = \max\{3,2+1\} = 3$
		\item[\underline{$j=5$}:] $r_7^2 = \max\{r_7^2, r_4^2 + 1\} = \max\{4,3+1\} = 4$
		\item[\underline{$j=6$}:] $r_8^2 = \max\{r_8^2, r_3^2 + 1\} = \max\{1,4+1\} = 5$
		\item[\underline{$j=7$}:] $r_7^2 = \max\{r_7^2, r_8^2 + 1\} = \max\{4,5+1\} = 6$
		\item[\underline{$j=8$}:] $r_7^2 = \max\{r_7^2, r_5^2 + 1\} = \max\{6,3+1\} = 6$
		\item[\underline{$j=9$}:] $r_3^2 = \max\{r_3^2, r_4^2 + 1\} = \max\{4,3+1\} = 4$
		\item[\underline{$j=10$}:] $r_3^2 = \max\{r_3^2, r_5^2 + 1\} = \max\{4,2+1\} = 4$
	\end{enumerate}

	\bigskip

	Запишем результаты в таблицу:

	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | c |} 
			\hline
			$k$ & $r_k^0$ & $r_k^1$ & $r_k^2$ \\ \hline
			$1$ & $0$ & $0$ & $0$ \\ \hline
			$2$ & $0$ & $1$ & $1$ \\ \hline
			$3$ & $0$ & $4$ & $4$ \\ \hline
			$4$ & $0$ & $3$ & $3$ \\ \hline
			$5$ & $0$ & $2$ & $2$ \\ \hline
			$6$ & $0$ & $2$ & $2$ \\ \hline
			$7$ & $0$ & $4$ & $6$ \\ \hline
			$8$ & $0$ & $1$ & $5$ \\ \hline
		\end{tabular}
	\end{table}

	\item[\fbox{$i=3$}] Следуя алгоритму, вычисляем $r^3_k$, используя табличный вид сети:

	\begin{enumerate}[nosep]
		\item[\underline{$j=1$}:] $r_2^3 = \max\{r_2^3, r_1^3 + 1\} = \max\{0,0+1\} = 1$
		\item[\underline{$j=2$}:] $r_6^3 = \max\{r_6^3, r_2^3 + 1\} = \max\{2,1+1\} = 2$
		\item[\underline{$j=3$}:] $r_5^3 = \max\{r_5^3, r_2^3 + 1\} = \max\{2,1+1\} = 2$
		\item[\underline{$j=4$}:] $r_4^3 = \max\{r_4^3, r_6^3 + 1\} = \max\{3,2+1\} = 3$
		\item[\underline{$j=5$}:] $r_7^3 = \max\{r_7^3, r_4^3 + 1\} = \max\{6,3+1\} = 6$
		\item[\underline{$j=6$}:] $r_8^3 = \max\{r_8^3, r_3^3 + 1\} = \max\{5,4+1\} = 5$
		\item[\underline{$j=7$}:] $r_7^3 = \max\{r_7^3, r_8^3 + 1\} = \max\{6,5+1\} = 6$
		\item[\underline{$j=8$}:] $r_7^3 = \max\{r_7^3, r_5^3 + 1\} = \max\{6,2+1\} = 6$
		\item[\underline{$j=9$}:] $r_3^3 = \max\{r_3^3, r_4^3 + 1\} = \max\{4,3+1\} = 4$
		\item[\underline{$j=10$}:] $r_3^3 = \max\{r_3^3, r_5^3 + 1\} = \max\{4,2+1\} = 4$
	\end{enumerate}

	\bigskip

	Запишем результаты в таблицу:

	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | c | c | } 
			\hline
			$k$ & $r_k^0$ & $r_k^1$ & $r_k^2$ & $r_k^3$ \\ \hline
			$1$ & $0$ & $0$ & $0$ & $0$ \\ \hline
			$2$ & $0$ & $1$ & $1$ & $1$ \\ \hline
			$3$ & $0$ & $4$ & $4$ & $4$ \\ \hline
			$4$ & $0$ & $3$ & $3$ & $3$ \\ \hline
			$5$ & $0$ & $2$ & $2$ & $2$ \\ \hline
			$6$ & $0$ & $2$ & $2$ & $2$ \\ \hline
			$7$ & $0$ & $4$ & $6$ & $6$ \\ \hline
			$8$ & $0$ & $1$ & $5$ & $5$ \\ \hline
		\end{tabular}
	\end{table}

	Как видно $\forall k \; r_k^2 = r_k^3$, значит алгоритм окончен: в столбце $r^3_k$ содержатся окончательные ранги вершин. Теперь нужно пронумеровать вершины графа согласно им (опять же по \hyperref[alg:ford]{алгоритму Форда}). Алгоритм будет следующий:
	
	\begin{enumerate}[nosep]
		\item присваиваем вершине с рангом 0 значение 1;
		\item смотрим имеются ли еще вершины с рангом последней пронумерованной, если есть, то даем ей следующий номер вершины и повторяем этот шаг, если нет, то приступаем к шагу 3, если же все вершины пронумерованы, то завершаем алгоритм;
		\item берем следующий ранг по возрастанию, приступаем к шагу 2.
	\end{enumerate}
	
	Этот алгоритм удобно выполнять, используя полученную таблицу и дописывая к ней столбец $H_k$, в котором будут итоговые номера вершин. Выполняя алгоритм, получаем следующую таблицу:
	
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | c | c | c |} 
			\hline
			$k$ & $r_k^0$ & $r_k^1$ & $r_k^2$ & $r_k^3$ & $H_k$ \\ \hline
			$1$ & $0$ & $0$ & $0$ & $0$ & $1$ \\ \hline
			$2$ & $0$ & $1$ & $1$ & $1$ & $2$ \\ \hline
			$3$ & $0$ & $4$ & $4$ & $4$ & $6$ \\ \hline
			$4$ & $0$ & $3$ & $3$ & $3$ & $5$ \\ \hline
			$5$ & $0$ & $2$ & $2$ & $2$ & $3$ \\ \hline
			$6$ & $0$ & $2$ & $2$ & $2$ & $4$ \\ \hline
			$7$ & $0$ & $4$ & $6$ & $6$ & $8$ \\ \hline
			$8$ & $0$ & $1$ & $5$ & $5$ & $7$ \\ \hline
		\end{tabular}
	\end{table}
\end{itemize}

Используя эти данные перенумеруем вершины сети (заменим старый номер вершины $k$ на $H_k$).

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=2.2]
		\node[vertex, label={\circled{1}}, fill=blue] (1) at (-4,0) {};
		\node[vertex, label={\circled{2}}] (2) at (-3,0) {};
		\node[vertex, label={\circled{4}}] (3) at (-2,-1) {};
		\node[vertex, label={\circled{3}}] (4) at (0,0) {};
		\node[vertex, label={\circled{5}}] (5) at (-1, -2) {};
		\node[vertex, label=above right:\circled{6}] (6) at (0,-1) {};
		\node[vertex, label=\circled{7}] (7) at (2,-1) {};
		\node[vertex, label={\circled{8}}, fill=blue, fill=blue] (8) at (3.5,-1) {};
		
		\draw[->, edge] (1) -- node[above] {\squared{1}} (2);
		\draw[->, edge] (2) -- node {} (3);
		\draw[->, edge] (3) -- node {} (5);
		\draw[->, edge] (2) -- node[above] {\squared{3}} (4);
		\draw[->, edge] (6) -- node[above] {\squared{6}} (7);
		\draw[->, edge] (7) -- node {} (8);
		\draw[->, edge] (4) -- node[above] {\squared{8}} (8);
		\draw[->, edge] (5) -- node[above] {\squared{5}} (8);
		
		\draw[->, edge, dashed] (4) -- node {} (6);
		\draw[->, edge, dashed] (5) -- node {} (6);
		
		\node at (2.4, -0.85) {\squared{7}};
		\node at (-2.35, -0.4) {\squared{2}};
		\node at (-1.5, -1.25) {\squared{4}};
		\node at (0.2, -0.4) {\squared{10}};
		\node at (-0.6, -1.3) {\squared{9}};
		
	\end{tikzpicture}
\end{figure}

\subsection{Проект вычисления математического выражения}

\project[вычисления математического выражения]\label{proj:math_expr_calc_project}

\textbf{Исходные данные}
Требуется для заданных величин $a, b$ построить сетевую модель проекта вычисления значения выражения

\[\boxed{\frac{\sqrt{ab}(a + b)^2}{\sqrt{a + b}(a + ab)}}\]

\bigskip

\textbf{Таблица работ}

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c | } 
		\hline
		j & описание работы & следующие работы \\\hline
		$1$ & $ab$ & $\{4,5\}$ \\\hline
		$2$ & $a+b$ & $\{3, 6\}$ \\\hline
		$3$ & $(a+b)^2$ & $\{7\}$ \\\hline
		$4$ & $\sqrt{ab}$ & $\{7\}$ \\\hline
		$5$ & $(a+ab)$ & $\{8\}$ \\\hline
		$6$ & $\sqrt{a+b}$ & $\{8\}$ \\\hline
		$7$ & $\sqrt{ab}(a+b)^2$ & $\{9\}$ \\\hline
		$8$ & $\sqrt{a+b}(a+ab)$ & $\{9\}$ \\\hline
		$9$ & $\frac{\sqrt{ab}(a + b)^2}{\sqrt{a + b}(a + ab)}$ & $\O$ \\\hline
	\end{tabular}
\end{table}

\bigskip

\textbf{Построение сетевой модели}

\begin{itemize}[nosep]
	\item[\fbox{Шаги 1, 2}] Построение вершин и дуг для каждой работы, обозначение подчиненностей, добавление начальной и конечной вершин.

	\begin{figure}[H]
		\centering	
		\begin{tikzpicture}[scale=2.2]
			\node[vertex, label=left:\textcolor{blue}{$s$}, fill=blue] (s) at (-3.5,-2.5) {};
			\node[vertex] (1) at (-3,-1) {};
			\node[vertex] (2) at (-2,-1) {};
			\node[vertex] (3) at (-3,-4) {};
			\node[vertex] (4) at (-2,-4) {};
			\node[vertex] (5) at (-1,-3) {};
			\node[vertex] (6) at (0,-3) {};
			\node[vertex] (7) at (-1,0) {};
			\node[vertex] (8) at (0, 0) {};
			\node[vertex] (9) at (-1,-2) {};
			\node[vertex] (10) at (0, -2) {};
			\node[vertex] (11) at (-1,-5) {};
			\node[vertex] (12) at (0, -5) {};
			\node[vertex] (13) at (1,-1) {};
			\node[vertex] (14) at (2,-1) {};
			\node[vertex] (15) at (1,-4) {};
			\node[vertex] (16) at (2,-4) {};
			\node[vertex] (17) at (3,-2.5) {};
			\node[vertex, label=right:\textcolor{blue}{$t$}, fill=blue] (18) at (4,-2.5) {};
			
			
			\draw[->, edge] (1) -- node[above] {\squared{1}} (2);
			\draw[->, edge] (3) -- node[above] {\squared{2}} (4);
			\draw[->, edge] (5) -- node[above] {\squared{3}} (6);
			\draw[->, edge] (7) -- node[above] {\squared{4}} (8);
			\draw[->, edge] (9) -- node[above] {\squared{5}} (10);
			\draw[->, edge] (11) -- node[above] {\squared{6}} (12);
			\draw[->, edge] (13) -- node[above] {\squared{7}} (14);
			\draw[->, edge] (15) -- node[above] {\squared{8}} (16);
			\draw[->, edge] (17) -- node[above] {\squared{9}} (18);
			\draw[->, edge] (s) -- node {} (1);
			\draw[->, edge] (s) -- node {} (3);
			
			\draw[->, edge, dashed] (2) -- node {} (7);
			\draw[->, edge, dashed] (2) -- node {} (9);
			\draw[->, edge, dashed] (4) -- node {} (5);
			\draw[->, edge, dashed] (4) -- node {} (11);
			\draw[->, edge, dashed] (12) -- node {} (15);
			\draw[->, edge, dashed] (6) -- node {} (13);
			\draw[->, edge, dashed] (8) -- node {} (13);
			\draw[->, edge, dashed] (10) -- node {} (15);
			\draw[->, edge, dashed] (14) -- node {} (17);
			\draw[->, edge, dashed] (16) -- node {} (17);
			
		\end{tikzpicture}
	\end{figure}

	\item[\fbox{Шаги 3,4}] Удаление фиктивных дуги и нумерация вершин

	\begin{figure}[H]
		\centering	
		\begin{tikzpicture}[scale=2.2]
			\node[vertex, label={\circled{1}}, fill=blue] (s) at (-3.5,-2.5) {};
			\node[vertex, label={\circled{2}}] (2) at (-2,-1) {};
			\node[vertex, label={\circled{3}}] (4) at (-2,-4) {};
			\node[vertex, label={\circled{5}}] (13) at (1,-1) {};
			\node[vertex, label={\circled{4}}] (15) at (1,-4) {};
			\node[vertex, label={\circled{6}}] (17) at (3,-2.5) {};
			\node[vertex, label={\circled{7}}, fill=blue] (18) at (4,-2.5) {};
			
			
			\draw[->, edge] (s) -- node[above=2mm] {\squared{1}} (2);
			\draw[->, edge] (s) -- node[above=2mm] {\squared{2}} (4);
			\draw[->, edge] (4) -- node[above=20mm, right=10mm] {\squared{3}} (13);
			\draw[->, edge] (2) -- node[above] {\squared{4}} (13);
			\draw[->, edge] (2) -- node[below=7mm, right=10mm] {\squared{5}} (15);
			\draw[->, edge] (4) -- node[above] {\squared{6}} (15);
			\draw[->, edge] (13) -- node[above=2mm] {\squared{7}} (17);
			\draw[->, edge] (15) -- node[above=2mm] {\squared{8}} (17);
			\draw[->, edge] (17) -- node[above] {\squared{9}} (18);
			
		\end{tikzpicture}
	\end{figure}
	
	Вершины данной сети нумеруются просто <<вручную>>, поэтому здесь нет нужды использовать \hyperref[alg:ford]{алгоритм Форда}.

\end{itemize}

\section{Поиск максимальных путей}\label{sec:max_length_path_searching}

\definition

\definitionfont{Длиной пути} $P(i_1, \dots, i_{L+1})$ называется
\[
\abs{P(i_1, \dots, i_{L+1})} = \sum_{l=1}^{L} \tau_{(i_l, i_{l+1})}
\]

\remark

Вместо суммы может стоять произведение, взятие максимума/минимума и так далее (всё зависит от конкретной задачи и сети).

\problem[поиска максимальных путей]

Есть некоторая сеть $G = (I, J)$, нужно найти все пути максимальной длины от первой до последней вершины ($1 \to n$).

\solution

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=2]
		\node[vertex, fill=blue] (1) at (-3,0) {};
		\node[vertex, fill=blue] (11) at (2.2,0) {};
		\node[vertex] (2) at (-2, 0) {};
		\node[vertex, label=right:$\dots$] (3) at (-1.6, 0.6) {};
		\node[vertex, label=right:$\dots$] (4) at (-1.6, -0.6) {};
		\node[vertex] (5) at (-1, 0) {};
		\node[vertex, label=right:$\dots$] (6) at (-0.6, 0.6) {};
		\node[vertex] (7) at (-0.6, -0.6) {};
		\node[vertex] (8) at (0, 0) {};
		\node[vertex, label=right:$\dots$] (9) at (0.6, 0) {};
		\node[vertex, label=left:$\dots$] (10) at (1.6, 0) {};
		\draw[->, edge] (1) -- node[left] {} (2);
		\draw[->, edge] (2) -- node[left] {} (3);
		\draw[->, edge] (2) -- node[left] {} (4);
		\draw[->, edge] (2) -- node[left] {} (5);
		\draw[->, edge] (5) -- node[left] {} (6);
		\draw[->, edge] (5) -- node[left] {} (7);
		\draw[->, edge] (7) -- node[left] {} (8);
		\draw[->, edge] (8) -- node[left] {} (9);
		\draw[->, edge] (10) -- node[left] {} (11);
		\draw[->, edge] (1) to[bend left=60] (11);
		\draw[->, edge] (1) to[bend right=60] (11);
	\end{tikzpicture}
	\caption{Задача поиска максимальных путей в сети}
\end{figure}

Для решения задачи будем использовать динамическое программирование. Поскольку нам не задано количество шагов (длины путей зависят от конкретной сети), то будем использовать \hyperref[alg:unknown_step_process]{многошаговый процесс принятия решений}. Вспомним, что по определению сети на множестве вершин задан строгий частичный порядок --- это соответствует требования многошагового процесса (<<согласованность>> функции перехода).

\bigskip

\textbf{Исходные данные}

Формализуем задачу поиска максимальных путей в терминах динамического программирования:

\begin{itemize}[nosep]
	\item \underline{состояние}: $i \in I$ (текущая вершина);
	
	\item \underline{решение}: $j \in J$ (дуга, по которой мы пойдём);
	
	\item \underline{множество возможных состояний}: $P = I$;
	
	\item \underline{множество конечных состояний}: $\bar{P} = \{n\}$;
	
	\item \underline{начальное состояние}: $p_0 = 1$;
	
	\item \underline{множество возможных решений}: $Q = J$;
	
	\item \underline{множество допустимых решений}: $Q(i) = \{j \; \big| \; i(j) = i\}$ (все дуги, по которым можно пойти из текущей вершины);
	
	\item \underline{функция перехода}: $T(i, j) = k(j)$ (находимся в вершине $i$ и двигаемся по дуге $j$);
	
	\item \underline{функция дохода}: $g(i, j) = \tau_j$.
\end{itemize}

\bigskip

\textbf{База процесса}

Пусть $f(i)$ --- длина максимального пути из вершины $i$ в вершину $n$, $f(1)$ --- ответ на вопрос исходной задачи. Так как длину пути можно представить как сумму длин входящих в него путей, по \hyperref[alg:unknown_step_process]{теории} $\boxed{f(n) = 0}$.

\bigskip

\textbf{Переход}

Пусть мы находимся в вершине $i$, тогда нам нужно рассмотреть все дуги, начинающиеся в данной вершине.

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=2]
		\node[vertex, label=left:$i$] (1) at (-3,0) {};
		\node[vertex] (2) at (-2.5,0) {};
		\node[vertex] (3) at (-2.6,0.4) {};
		\node[vertex] (4) at (-2.6,-0.4) {};
		
		\draw[->, edge] (1) -- node[left] {} (2);
		\draw[->, edge] (1) -- node[left] {} (3);
		\draw[->, edge] (1) -- node[left] {} (4);
	\end{tikzpicture}
	\caption{Пример дуг, начинающихся в вершине $i$}
\end{figure}

Таким образом
\[
\boxed{f(i) = \max_{j: \; i(j) = i} \Big\{\tau_j + f\big(k(j)\big)\Big\}}\tag{*}.
\]

Так как $k(j) > 1$, то значение $f\big(k(j)\big)$ нам известно.

\bigskip

\textbf{Выбор оптимальной стратегии}

Будем записывать все данные в следующую таблицу

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c |} 
		\hline
		$i$ & $f(i)$ & $j(i)$\\ 
		\hline
		$1$ &&\\\hline
		$2$ && \\\hline
		$\dots$ && \\\hline
		$n-1$ && \\\hline
		$n$ && \\\hline
	\end{tabular}
\end{table}

$j(i)$ --- дуга, на которой достигается максимум в (*).

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=2]
		\node[vertex, fill=blue, label=left:{$i=1$}] (1) at (-3,0) {};
		\node[vertex, fill=blue, label=right:{$i=n$}] (11) at (2.2,0) {};
		\node[vertex] (2) at (-2, 0) {};
		\node[vertex, label=right:$\dots$] (3) at (-1.6, 0.6) {};
		\node[vertex, label=right:$\dots$] (4) at (-1.6, -0.6) {};
		\node[vertex] (5) at (-1, 0) {};
		\node[vertex, label=right:$\dots$] (6) at (-0.6, 0.6) {};
		\node[vertex] (7) at (-0.6, -0.6) {};
		\node[vertex] (8) at (0, 0) {};
		\node[vertex, label=right:$\dots$] (9) at (0.6, 0) {};
		\node[vertex, label=left:$\dots$] (10) at (1.6, 0) {};
		\draw[->, edge, thick, red] (1) -- node[above] {$j(1)$} (2);
		\draw[->, edge] (2) -- node[left] {} (3);
		\draw[->, edge] (2) -- node[left] {} (4);
		\draw[->, edge, thick, red] (2) -- node[above] {$j(2)$} (5);
		\draw[->, edge] (5) -- node[left] {} (6);
		\draw[->, edge, thick, red] (5) -- node[left] {$j(3)$} (7);
		\draw[->, edge, thick, red] (7) -- node[below right] {$j(4)$} (8);
		\draw[->, edge, thick, red] (8) -- node[above]{$j(5)$} (9);
		\draw[->, edge, thick, red] (10) -- node[above] {$j(n-1)$} (11);
		\draw[->, edge] (1) to[bend left=60] (11);
		\draw[->, edge] (1) to[bend right=60] (11);
	\end{tikzpicture}
	\caption{Пример оптимальной стратегии}
\end{figure}

\remark

По ходу процесса, мы узнаем максимальные пути из каждой вершины в $n$-ую. Однако на будущее хотелось бы знать про максимальные пути из $1$-ой вершины в любую. Для этого можно проделать тот же самый процесс, но идти не $1 \to n$, а $n \to 1$.

\bigskip

\textbf{База процесса}

Пусть $g(i)$ --- длина максимального пути из вершины $i$ в вершину $1$. По \hyperref[alg:unknown_step_process]{теории} $\boxed{g(1) = 0}$.

\bigskip

\textbf{Переход}

\[
\boxed{g(i) = \max_{j': \; k(j') = i} \Big\{\tau_{j'} + g\big(i(j')\big)\Big\}}.
\]

Так как $i(j') < i$, то значение $g\big(i(j')\big)$ нам известно.

\bigskip

\textbf{Выбор оптимальной стратегии}

Итоговая таблица имеет следующий вид

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c | c | c| } 
		\hline
		$i$ & $f(i)$ & $j(i)$ & $g(i)$ & $j'(i)$ \\ 
		\hline
		$1$ &&&&\\\hline
		$2$ &&&& \\\hline
		$\dots$ &&&& \\\hline
		$n-1$ &&&& \\\hline
		$n$ &&&& \\\hline
	\end{tabular}
\end{table}

\remark

$f(1) = g(n)$.

\remark

Пусть исходная сеть соответствовала некоторому проекту с набором работ $J$ и продолжительностями работ $\{\tau_j\}$. Проект будет реализован, если будут реализованы самые длинны пути $1 \to n$.

\notation

\begin{itemize}
	\item[]
	
	\item $T_i^{\text{р}}$ (\definitionfont{самое ранее время наступления события} $i$). Это равняется длине максимального пути из $1$-ой вершины в $i$-ую.
	
	\item $T = T_n^{\text{р}} = g(n) = f(1)$ (\definitionfont{критическое время проекта}).
	
	\item $T_i^{\text{П}} = T - f(i)$ (\definitionfont{наиболее позднее время наступления события} $i$).
\end{itemize}

\definition

Путь будем называть \definitionfont{критическим}, если его длина равняется $T$.

\definition

Работу будем называться \definitionfont{критической}, если дуга, соответствующая этой работе, входит в состав критического пути.

\remark

Если увеличить время критической работы, то время проекта увеличится.

\remark

Мы уже говорили, что если работа критическая, то увеличивать её время нежелательно, так как увеличится время всего проекта. А если работа не критическая, то можно ли увеличить её время? И если можно, то насколько?

\fact\label{fact:max_delta_j}

Пусть $\Delta_j$ --- увеличение времени работы $j$, тогда максимальное значение $\Delta_j$, которое не приведёт к увеличению времени проекта, вычисляется по формуле
\[
\Delta_j^{\max} = T - f\big(k(j)\big) - g\big(i(j)\big) - \tau_j.
\]

\prooof

Заметим, что
\[
g\big(i(j)\big) + \tau_j + f\big(k(j)\big) \le T\tag{*}.
\]

Действительно, левая часть --- это максимальная длина пути, содержащего дугу $j$, а правая часть --- максимальная длина пути во всей сети. То есть мы рассматриваем пути с максимальной длиной, при этом слева лишь пути через дугу $j$, а справа --- все пути в сети. 

Из неравенства следует, что к левой части можно добавить некоторое $\Delta_j \ge 0$ так, чтобы неравенство всё ещё выполнялось. Максимальное $\Delta_j$, которое можно прибавить, это значение, при котором будет достигаться равенство, то есть
\[
g\big(i(j)\big) + \tau_j + \Delta_j^{\max} + f\big(k(j)\big) = T,
\]
\[
\Downarrow
\]
\[
\Delta_j^{\max} = T - f\big(k(j)\big) - g\big(i(j)\big) - \tau_j.
\]

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=2]
		\node[vertex, fill=blue, label=left:{$i=1$}] (1) at (-3,0) {};
		\node[vertex] (2) at (-2.55,0.45) {};
		\node[vertex, label=left:{$\dots$}] (3) at (-2.45,0.55) {};
		\node[vertex, label=above:{$i(j)$}] (4) at (-2,1) {};
		\node[vertex, label=above:{$k(j)$}] (5) at (0,1) {};
		\node[vertex, label=right:{$\dots$}] (6) at (0.45,0.55) {};
		\node[vertex] (7) at (0.55,0.45) {};
		\node[vertex, fill=blue, label=right:{$i=n$}] (8) at (1,0) {};
		\node at (-1,1.3) {$\tau_j + \Delta_j$};
		\draw[->, edge] (1) to[bend left=15] (2);
		\draw[->, edge] (3) to[bend left=15] (4);
		\draw[->, edge] (4) to[bend left=15] (5);
		\draw[->, edge] (5) to[bend left=15] (6);
		\draw[->, edge] (7) to[bend left=15] (8);
		\draw [<->] (-3.5, 0.5) -- node[above left = -1mm] {$g\big(i(j)\big)$} (-2.5, 1.5);
		
		\draw [<->] (1.5, 0.5) -- node[above right = -1mm] {$f\big(k(j)\big)$} (0.5, 1.5);
	\end{tikzpicture}
	\caption{Иллюстрация к (*)}
\end{figure}

\implication

\begin{itemize}[nosep]
	\item[]
	
	\item Если $\Delta_j > \Delta_j^{\max}$, то время проекта увеличится;
	
	\item Если $\Delta_j \le \Delta_j^{\max}$, то время проекта не изменится.
\end{itemize}

\implication

\[
\Delta_j^{\max} = T_{k(j)}^{\text{П}} - T_{i(j)}^{\text{р}} - \tau_j.
\]

\section{Практика поиска максимальных путей}

\subsection{Проект вычисления математического выражения}

\problem[о времени вычисления математического выражения]\label{pr:math_expr_calc_time}

Добавим в \hyperref[proj:math_expr_calc_project]{проект вычисления математического выражения} данные о единицах времени, необходимых на вычисление математических операций:

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | } 
		\hline
		Операция & Трудоёмкость \\ \hline
		Сложение & $1$ \\ \hline
		Умножение & $2$ \\ \hline
		Деление & $4$ \\ \hline
		Извлечение корня & $6$ \\ \hline
	\end{tabular}
\end{table}

\underline{Требуется}: найти наименьшее время, за которое можно вычислить выражение, если число вычислителей не ограничено; насколько можно увеличить время работ так, чтобы время выполнения проекта не увеличилось.

\solution

\textbf{Постройка взвешенной сети}

Сеть для данного проекта уже построена, дополним её весами рёбер, исходя из таблицы выше.

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[scale=2.2]
		\node[vertex, label={\circled{1}}, fill=blue] (s) at (-3.5,-2.5) {};
		\node[vertex, label={\circled{2}}] (2) at (-2,-1) {};
		\node[vertex, label={\circled{3}}] (4) at (-2,-4) {};
		\node[vertex, label={\circled{5}}] (13) at (1,-1) {};
		\node[vertex, label={\circled{4}}] (15) at (1,-4) {};
		\node[vertex, label={\circled{6}}] (17) at (3,-2.5) {};
		\node[vertex, label={\circled{7}}, fill=blue] (18) at (4,-2.5) {};
		
		\draw[->, edge] (s) -- node[above=2mm] {\squared{1}} node[below] {$2$} (2);
		\draw[->, edge] (s) -- node[above=2mm] {\squared{2}} node[below] {$1$} (4);
		\draw[->, edge] (4) -- node[above=20mm, right=10mm] {\squared{3}} node[above=10mm, right=12mm] {$2$} (13);
		\draw[->, edge] (2) -- node[above] {\squared{4}} node[below] {$6$} (13);
		\draw[->, edge] (2) -- node[below=7mm, right=10mm] {\squared{5}} node[below=16mm, right=10mm] {$1$} (15);
		\draw[->, edge] (4) -- node[above] {\squared{6}} node[below] {$6$} (15);
		\draw[->, edge] (13) -- node[above=2mm] {\squared{7}} node[below] {$2$} (17);
		\draw[->, edge] (15) -- node[above=2mm] {\squared{8}} node[below] {$2$} (17);
		\draw[->, edge] (17) -- node[above] {\squared{9}} node[below] {$4$} (18);	
	\end{tikzpicture}
\end{figure}

\bigskip

\textbf{Динамическое программирование}

Для решения поставленной задачи необходимо найти максимальную длину пути из вершины $1$ в вершину $7$ (\textbf{критическое время}). Решение подобных задач было разобрано в разделе \hyperref[sec:max_length_path_searching]{Поиск максимальных путей}, поэтому сразу приступим к решению.

Пусть $f(i)$ --- длина максимального пути из вершины $i$ в вершину $n=7$.

\[\boxed{f(i) = \max_{j: \; i(j) = i} \Big\{\tau_j + f\big(k(j)\big)\Big\}}\tag{*}\]

Во время решения будем заполнять следующую таблицу:

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c | } 
		\hline
		$i$ & $f(i)$ & $j(i)$ \\ \hline
		$1$ & & \\ \hline
		$2$ & & \\ \hline
		$3$ & & \\ \hline
		$4$ & & \\ \hline
		$5$ & & \\ \hline
		$6$ & & \\ \hline
		$7$ & & \\ \hline
	\end{tabular}
\end{table}

где $j(i)$ --- номер дуги, с которой начинается максимально длинный путь из $i$ в $n$.

Будем заполнять таблицу, начиная с $f(7)$ и проходясь по индексам вниз вплоть до $f(1)$, где находится наше решение.
Для этого будем вычислять $f(i)$, выписывая в столбец разные $j$, считая для них $\tau_j + f(k(j))$ и обводя в кружок то значение, на котором достигается максимум.

\begin{note}
	\textbf{Напоминание}: $i(j)$ --- вершина-начало дуги $j$, $k(j)$ --- вершина-конец дуги $j$.
\end{note}

\bigskip

\textbf{Заполнение таблицы}
\begin{enumerate}[nosep]
	\item[\fbox{$i=7$}]
	
	$f(7)$ --- длина максимально длинного пути из вершины 7 в вершину 7, очевидно что здесь нет никакого пути, значит $f(7) = 0$, а $j(7)$ не определено.
	
	Запишем результат в таблицу:
	
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | } 
			\hline
			$i$ & $f(i)$ & $j(i)$ \\ \hline
			$1$ & & \\ \hline
			$2$ & & \\ \hline
			$3$ & & \\ \hline
			$4$ & & \\ \hline
			$5$ & & \\ \hline
			$6$ & & \\ \hline
			$7$ & $0$ & $-$ \\ \hline
		\end{tabular}
	\end{table}
	
	\item[\fbox{$i=6$}] Для вычисления $f(i)$ на этом и последующем шагах будем использовать (*).
	
	\[
	f(6) = \begin{array}{c|l}
		\underbrace{9}_{j} & \tau_9 + f(\underbrace{7}_{k(9)}) = 4 + 0 = \circled{4} \\
	\end{array}
	\]
	
	Запишем результат в таблицу:
	
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | } 
			\hline
			$i$ & $f(i)$ & $j(i)$ \\ \hline
			$1$ & & \\ \hline
			$2$ & & \\ \hline
			$3$ & & \\ \hline
			$4$ & & \\ \hline
			$5$ & & \\ \hline
			$6$ & $4$ & $9$ \\ \hline
			$7$ & $0$ & $-$ \\ \hline
		\end{tabular}
	\end{table}
	
	\item[\fbox{$i=5$}]
	
	\[
	f(5) = \begin{array}{c|l}
		\underbrace{7}_{j} & \tau_9 + f(\underbrace{6}_{k(7)}) = 2 + 4 = \circled{6} \\
	\end{array}
	\]
	
	Запишем результат в таблицу:
	
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | } 
			\hline
			$i$ & $f(i)$ & $j(i)$ \\ \hline
			$1$ & & \\ \hline
			$2$ & & \\ \hline
			$3$ & & \\ \hline
			$4$ & & \\ \hline
			$5$ & $6$ & $7$ \\ \hline
			$6$ & $4$ & $9$ \\ \hline
			$7$ & $0$ & $-$ \\ \hline
		\end{tabular}
	\end{table}
	
	\item[\fbox{$i=4$}]
	
	\[
	f(4) = \begin{array}{c|l}
		\underbrace{8}_{j} & \tau_8 + f(\underbrace{6}_{k(8)}) = 2 + 4 = \circled{6} \\
	\end{array}
	\]
	
	Запишем результат в таблицу:
	
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | } 
			\hline
			$i$ & $f(i)$ & $j(i)$ \\ \hline
			$1$ & & \\ \hline
			$2$ & & \\ \hline
			$3$ & & \\ \hline
			$5$ & $6$ & $8$ \\ \hline
			$5$ & $6$ & $7$ \\ \hline
			$6$ & $4$ & $9$ \\ \hline
			$7$ & $0$ & $-$ \\ \hline
		\end{tabular}
	\end{table}
	
	\item[\fbox{$i=3$}]
	
	\[
	f(3) = \begin{array}{c|l}
		3 & \tau_3 + f(\underbrace{5}_{k(3)}) = 2 + 6 = 8 \\
		\underbrace{6}_{j} & \tau_6 + f(\underbrace{4}_{k(6)}) = 6 + 6 = \circled{12} \\
	\end{array}
	\]
	
	Запишем результат в таблицу:
	
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | } 
			\hline
			$i$ & $f(i)$ & $j(i)$ \\ \hline
			$1$ & & \\ \hline
			$2$ & & \\ \hline
			$3$ & $12$ & $6$ \\ \hline
			$5$ & $6$ & $8$ \\ \hline
			$5$ & $6$ & $7$ \\ \hline
			$6$ & $4$ & $9$ \\ \hline
			$7$ & $0$ & $-$ \\ \hline
		\end{tabular}
	\end{table}
	
	\item[\fbox{$i=2$}]
	
	\[
	f(2) = \begin{array}{c|l}
		4 & \tau_4 + f(\underbrace{5}_{k(4)}) = 6 + 6 = \circled{12} \\
		\underbrace{5}_{j} & \tau_5 + f(\underbrace{4}_{k(5)}) = 1 + 6 = 7 \\
	\end{array}
	\]
	
	Запишем результат в таблицу:
	
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | } 
			\hline
			$i$ & $f(i)$ & $j(i)$ \\ \hline
			$1$ & & \\ \hline
			$2$ & $12$ & $4$ \\ \hline
			$3$ & $12$ & $6$ \\ \hline
			$5$ & $6$ & $8$ \\ \hline
			$5$ & $6$ & $7$ \\ \hline
			$6$ & $4$ & $9$ \\ \hline
			$7$ & $0$ & $-$ \\ \hline
		\end{tabular}
	\end{table}
	
	\item[\fbox{$i=1$}]
	
	\[
	f(1) = \begin{array}{c|l}
		1 & \tau_1 + f(\underbrace{2}_{k(1)}) = 2 + 12 = \circled{14} \\
		\underbrace{2}_{j} & \tau_2 + f(\underbrace{3}_{k(2)}) = 1 + 12 = 13 \\
	\end{array}
	\]
	
	Запишем результат в таблицу:
	
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | } 
			\hline
			$i$ & $f(i)$ & $j(i)$ \\ \hline
			$1$ & $14$ & $1$ \\ \hline
			$2$ & $12$ & $4$ \\ \hline
			$3$ & $12$ & $6$ \\ \hline
			$5$ & $6$ & $8$ \\ \hline
			$5$ & $6$ & $7$ \\ \hline
			$6$ & $4$ & $9$ \\ \hline
			$7$ & $0$ & $-$ \\ \hline
		\end{tabular}
	\end{table}
	
\end{enumerate}

\bigskip

\textbf{Определение пути}

Мы заполнили таблицу, длина максимального пути оказалась равна $f(1) = 14$. Теперь по таблице вычислим этот путь.

Для этого рассмотрим столбец $j(i)$ --- это, как помним, дуги, с которых начинается максимальный путь для $f(i)$.

Путь начинается в вершине $\circled{1}$, по таблице видно, что $j(1) = \squared{1}$, а дуга с номером $\squared{1}$ ведет в вершину $\circled{2}$, смотрим для неё $j(2)$ и идём так по вершинам, пока не достигнем вершины с номером $\circled{7}$. Графически этот путь выглядит так:

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[
		vertex/.style={circle, draw, minimum size=1cm, font=\large},
		scale=2.2
		]
		\node[vertex] (1) at (0, 0) {$1$};
		\node[vertex] (2) at (1, 0) {$2$};
		\node[vertex] (3) at (2, 0) {$5$};
		\node[vertex] (4) at (3, 0) {$6$};
		\node[vertex] (5) at (4, 0) {$7$};
		
		\draw[->, edge] (1) -- node[above] {\squared{1}} node[below] {$2$} (2);
		\draw[->, edge] (2) -- node[above] {\squared{4}} node[below] {$6$} (3);
		\draw[->, edge] (3) -- node[above] {\squared{7}} node[below] {$2$} (4);
		\draw[->, edge] (4) -- node[above] {\squared{9}} node[below] {$4$} (5);
		
	\end{tikzpicture}
	\caption{Путь максимальной длины из вершины $1$ в вершину $7$. Сверху дуг --- номер дуги в сети, снизу --- её вес}
\end{figure}

\bigskip

\textbf{Вычисление резерва времени выполнения работы}

Можно заметить, что максимальный (критический) путь не содержит дугу $3$. Для примера вычислим резерв времени выполнения работы $3$, то есть на сколько максимально можно увеличить время этой работы, чтобы общее время не увеличилось. По \hyperref[fact:max_delta_j]{утверждению}

\[
\Delta^{max}_3 = T - f(k(3)) - g(i(3)) - \tau_3 = 14 - f(5) - g(3) - 2 = 5,
\]

\begin{itemize}[nosep]
	\item $T$ --- общее время проекта (длина максимального пути);
	
	\item $f(5)$ берётся взять из заполненной таблицы;
	
	\item $g(3)$ --- максимальная длина пути от вершины $1$ до вершины $3$, по графу можно определить, что $g(3) = 1$;
	
	\item $\tau_3$ --- вес (трудоёмкость) дуги $3$, берётся из условия задачи.
\end{itemize}


Таким образом, время выполнения работы $3$ (возведение $a+b$ в квадрат) можно увеличить на 5 единиц и время выполнения проекта не изменится.

\subsection{Проект постройки дома}

\problem[о времени постройки дома]

Добавим в \hyperref[proj:house_building_project]{проект постройки дома} данные о единицах времени, необходимых на выполнение работ. Сделаем это сразу в табличный вид сети, добавив столбец с весами дуг:

\begin{table}[H]
	\centering
	\begin{tabular}{ | c | c | c | c |} 
		\hline
		$j$ & $i(j)$ & $k(j)$ & $\tau(j)$ \\ \hline
		
		$1$ & $1$ & $2$ & $0.5$ \\ \hline
		$2$ & $2$ & $4$ & $0.5$ \\ \hline
		$3$ & $2$ & $3$ & $1$ \\ \hline
		$4$ & $4$ & $5$ & $4$ \\ \hline
		$5$ & $5$ & $8$ & $1$ \\ \hline
		$6$ & $6$ & $7$ & $2$ \\ \hline
		$7$ & $7$ & $8$ & $2$ \\ \hline
		$8$ & $3$ & $8$ & $3$ \\ \hline
		$9$ & $5$ & $6$ & $0$ \\ \hline
		$10$ & $3$ & $6$ & $0$ \\ \hline
	\end{tabular}
\end{table}

\underline{Требуется}: вычислить критическое время проекта и резервы времени работ.

\solution

Решение данной задачи почти никак отличается от решения \hyperref[pr:math_expr_calc_time]{предыдущей} (лишь сетью), поэтому сразу приступим к заполнению таблицы.

\bigskip

\textbf{Заполнение таблицы}
\begin{enumerate}[nosep]
	\item[\fbox{$i=8$}]
	
	$f(8) = 0$, $j(8)$ не определено. Запишем результат в таблицу:
	
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | } 
			\hline
			$i$ & $f(i)$ & $j(i)$ \\ \hline
			$1$ & & \\ \hline
			$2$ & & \\ \hline
			$3$ & & \\ \hline
			$4$ & & \\ \hline
			$5$ & & \\ \hline
			$6$ & & \\ \hline
			$7$ & & \\ \hline
			$8$ & $0$ & $-$ \\ \hline
		\end{tabular}
	\end{table}
	
	\item[\fbox{$i=7$}]
	
	\[
	f(7) = \begin{array}{c|l}
		7 & \tau_7 + f(8) = 2 + 0 = \circled{2} \\
	\end{array}
	\]
	
	Запишем результат в таблицу:
	
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | } 
			\hline
			$i$ & $f(i)$ & $j(i)$ \\ \hline
			$1$ & & \\ \hline
			$2$ & & \\ \hline
			$3$ & & \\ \hline
			$4$ & & \\ \hline
			$5$ & & \\ \hline
			$6$ & & \\ \hline
			$7$ & $2$ & $7$ \\ \hline
			$8$ & $0$ & $-$ \\ \hline
		\end{tabular}
	\end{table}
	
	\item[\fbox{$i=6$}]
	
	\[
	f(6) = \begin{array}{c|l}
		6 & \tau_6 + f(7) = 2 + 2 = \circled{4} \\
	\end{array}
	\]
	
	Запишем результат в таблицу:
	
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | } 
			\hline
			$i$ & $f(i)$ & $j(i)$ \\ \hline
			$1$ & & \\ \hline
			$2$ & & \\ \hline
			$3$ & & \\ \hline
			$4$ & & \\ \hline
			$5$ & & \\ \hline
			$6$ & $4$ & $6$ \\ \hline
			$7$ & $2$ & $7$ \\ \hline
			$8$ & $0$ & $-$ \\ \hline
		\end{tabular}
	\end{table}
	
	\item[\fbox{$i=5$}]
	
	\[
	f(5) = \begin{array}{c|l}
		5 & \tau_5 + f(8) = 1 + 0 = 1 \\
		9 & \tau_9 + f(6) = 0 + 4 = \circled{4} \\
	\end{array}
	\]
	
	Запишем результат в таблицу:
	
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | } 
			\hline
			$i$ & $f(i)$ & $j(i)$ \\ \hline
			$1$ & & \\ \hline
			$2$ & & \\ \hline
			$3$ & & \\ \hline
			$4$ & & \\ \hline
			$5$ & $4$ & $9$ \\ \hline
			$6$ & $4$ & $6$ \\ \hline
			$7$ & $2$ & $7$ \\ \hline
			$8$ & $0$ & $-$ \\ \hline
		\end{tabular}
	\end{table}
	
	\item[\fbox{$i=4$}]
	
	\[
	f(4) = \begin{array}{c|l}
		4 & \tau_4 + f(5) = 4 + 4 = \circled{8} \\
	\end{array}
	\]
	
	Запишем результат в таблицу:
	
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | } 
			\hline
			$i$ & $f(i)$ & $j(i)$ \\ \hline
			$1$ & & \\ \hline
			$2$ & & \\ \hline
			$3$ & & \\ \hline
			$4$ & $8$ & $4$ \\ \hline
			$5$ & $4$ & $9$ \\ \hline
			$6$ & $4$ & $6$ \\ \hline
			$7$ & $2$ & $7$ \\ \hline
			$8$ & $0$ & $-$ \\ \hline
		\end{tabular}
	\end{table}
	
	\item[\fbox{$i=3$}]
	
	\[
	f(3) = \begin{array}{c|l}
		8 & \tau_8 + f(8) = 3 + 0 = 3 \\
		10 & \tau_10 + f(6) = 0 + 4 = \circled{4} \\
	\end{array}
	\]
	
	Запишем результат в таблицу:
	
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | } 
			\hline
			$i$ & $f(i)$ & $j(i)$ \\ \hline
			$1$ & & \\ \hline
			$2$ & & \\ \hline
			$3$ & $4$ & $10$ \\ \hline
			$4$ & $8$ & $4$ \\ \hline
			$5$ & $4$ & $9$ \\ \hline
			$6$ & $4$ & $6$ \\ \hline
			$7$ & $2$ & $7$ \\ \hline
			$8$ & $0$ & $-$ \\ \hline
		\end{tabular}
	\end{table}
	
	\item[\fbox{$i=2$}]
	
	\[
	f(2) = \begin{array}{c|l}
		2 & \tau_2 + f(4) = 0.5 + 8 = \circled{8.5} \\
		3 & \tau_3 + f(3) = 1 + 4 = 5 \\
	\end{array}
	\]
	
	Запишем результат в таблицу:
	
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | } 
			\hline
			$i$ & $f(i)$ & $j(i)$ \\ \hline
			$1$ & & \\ \hline
			$2$ & $8.5$ & $2$ \\ \hline
			$3$ & $4$ & $10$ \\ \hline
			$4$ & $8$ & $4$ \\ \hline
			$5$ & $4$ & $9$ \\ \hline
			$6$ & $4$ & $6$ \\ \hline
			$7$ & $2$ & $7$ \\ \hline
			$8$ & $0$ & $-$ \\ \hline
		\end{tabular}
	\end{table}
	
	\item[\fbox{$i=1$}]
	
	\[
	f(1) = \begin{array}{c|l}
		1 & \tau_1 + f(2) = 0.5 + 8.5 = \circled{9} \\
	\end{array}
	\]
	
	Запишем результат в таблицу:
	
	\begin{table}[H]
		\centering
		\begin{tabular}{ | c | c | c | } 
			\hline
			$i$ & $f(i)$ & $j(i)$ \\ \hline
			$1$ & $9$ & $1$ \\ \hline
			$2$ & $8.5$ & $2$ \\ \hline
			$3$ & $4$ & $10$ \\ \hline
			$4$ & $8$ & $4$ \\ \hline
			$5$ & $4$ & $9$ \\ \hline
			$6$ & $4$ & $6$ \\ \hline
			$7$ & $2$ & $7$ \\ \hline
			$8$ & $0$ & $-$ \\ \hline
		\end{tabular}
	\end{table}
	
\end{enumerate}

\bigskip

\textbf{Определение пути}

Метод определения пути по заполненной таблице аналогичен методу из предыдущей задачи.

\begin{figure}[H]
	\centering	
	\begin{tikzpicture}[
		vertex/.style={circle, draw, minimum size=1cm, font=\large},
		scale=2.2
		]
		\node[vertex] (1) at (0, 0) {$1$};
		\node[vertex] (2) at (1, 0) {$2$};
		\node[vertex] (3) at (2, 0) {$4$};
		\node[vertex] (4) at (3, 0) {$5$};
		\node[vertex] (5) at (4, 0) {$6$};
		\node[vertex] (6) at (5, 0) {$7$};
		\node[vertex] (7) at (6, 0) {$8$};
		
		\draw[->, edge] (1) -- node[above] {\squared{1}} node[below] {$0.5$} (2);
		\draw[->, edge] (2) -- node[above] {\squared{2}} node[below] {$0.5$} (3);
		\draw[->, edge] (3) -- node[above] {\squared{4}} node[below] {$4$} (4);
		\draw[->, edge] (4) -- node[above] {\squared{9}} node[below] {$0$} (5);
		\draw[->, edge] (5) -- node[above] {\squared{6}} node[below] {$2$} (6);
		\draw[->, edge] (6) -- node[above] {\squared{7}} node[below] {$2$} (7);
	\end{tikzpicture}
	\caption{Путь максимальной длины из вершины $1$ в вершину $8$. Сверху дуг --- номер дуги в сети, снизу --- её вес}
\end{figure}

\bigskip

\textbf{Вычисление резерва времени выполнения работы}

Можно заметить, что максимальный путь не содержит дугу $3$. Для примера вычислим резерв времени выполнения работы, соответствующей этой дуге. Сделаем это аналогично тому, как мы делали в предыдущей задаче:

\[
\Delta^{max}_3 = T - f(k(3)) - g(i(3)) - \tau_3 = 9 - f(3) - g(2) - 1 = 8 - 4 - 0.5 = 3.5,
\]

то есть время выполнения работы $3$ (<<прокладка наружных коммуникаций>>) можно увеличить на $3.5$ и время выполнения проекта не изменится.

\section{Задача о максимальном потоке}

\definition

Пусть
\begin{itemize}[nosep]
	\item $G = (I, J)$ --- взвешенная сеть;
	
	\item $i = 1$ --- вход, $i = n$ --- выход;
	
	\item $b_{ik}$ --- вес дуги $\vec{ik}$;
\end{itemize}

тогда $x = (x_{ik})$ будем называть \definitionfont{потоком в сети} с величиной входного потока $v(x)$, если выполняются следующие ограничения
\[
\forall l \in I \quad \sum_{k:\;(l, k) \in J} x_{lk} - \sum_{i: \; (i, l) \in J} x_{il} = \begin{cases}
	v, & l = 1, \\
	0, & l = 2 \dots n-1, \\
	-v, & l = n;
\end{cases}\tag{1}
\]

\[
\forall j = (i, k) \quad x_{ik} \le b_{ik}\tag{2}.
\]

\definition

\definitionfont{Величину потока $x$ в сети} будем обозначать $v(x)$.

\definition

Пару $(S, \bar{S})$ будем называть \definitionfont{разрезом сети}, если $S$ и $\bar{S}$ разбивают множество вершин сети, при этом $1 \in S$, $n \in \bar{S}$.

\definition

\definitionfont{Пропускной способностью разреза} будем называть сумму пропускных способностей всех дуг, идущих из $S$ в $\bar{S}$
\[
B(S, \bar{S}) = \sum_{\underset{i \in S, k \in \bar{S}}{(i, k) \in J}} b_{ik}
\]

\fact[свойство разреза]

Для любого потока $x = (x_{ik})$ и любого разреза $(S, \bar{S})$
\[
v(x) \le B(S, \bar{S}).
\]

\prooof

Определим величину

\[
Z = \sum_{l \in S} \underbrace{\bigg(\sum_{k:\;(l, k) \in J} x_{lk} - \sum_{i: \; (i, l) \in J} x_{il}\bigg)}_{\text{<<баланс>> для } l}.
\]

\begin{itemize}[nosep]
	\item[\fbox{1}] Вспомним, что по определению разреза $1 \in S$, а также вспомним (1) из определения потока в сети, из всего этого следует, что
	\[
	Z = \underbrace{v(x)}_{1 = l \in S} + \underbrace{0 + \dots + 0}_{1 \neq l \in S} = v(x).
	\]
	
	\item[\fbox{2}] Величина $Z$ представляет собой сумму <<балансов>> для каждой вершины $l \in S$. Пусть $E(l)$ --- множество всех дуг, которые встречаются в <<балансе>> для вершины $l$. Заметим, что в $E(l)$ некоторые дуги встречаются два раза: и в $\sum x_{lk}$, и в $\sum {x_{il}}$.
	
	Рассмотрим некоторую дугу $(i, k) \in E(l)$, на \hyperref[fig:ik_placement]{рисунке} изображены возможные случаи взаимного расположения её вершин.
	
	\begin{figure}[H]
		\centering
		\begin{subfigure}{\linewidth}
			\begin{figure}[H]
				\centering	
				\begin{tikzpicture}
					\draw[very thick, dashed](0,0) circle (1.5);
					\node[vertex, label=left:{$i$}] (i) at (-0.8,0) {};
					\node[vertex, label=right:{$k$}] (k) at (0.8,0) {};
					\draw (i) -- node {} (k);
					\draw[->, edge] (i) -- node {} (k);
					\node at (-1.5,1.1) {\large$S$};
				\end{tikzpicture}
				\caption{Случай 1: $i \in S, k \in S$}
			\end{figure}
		\end{subfigure}
		\vfil
		\begin{subfigure}{\linewidth}
			\begin{figure}[H]
				\centering	
				\begin{tikzpicture}
					\draw[very thick, dashed](0,0) circle (1.5);
					\draw[very thick, dashed](5,0) circle (1.5);
					\node[vertex, label=left:{$i$}] (i) at (0.5,0) {};
					\node[vertex, label=right:{$k$}] (k) at (4.5,0) {};
					\draw (i) -- node {} (k);
					\draw[->, edge] (i) -- node {} (k);
					\node at (-1.5,1.1) {\large$S$};
					\node at (6.5,1.1) {\large$\bar{S}$};
				\end{tikzpicture}
				\caption{Случай 2: $i \in S, k \in \bar{S}$}
			\end{figure}
		\end{subfigure}
		\vfil
		\begin{subfigure}{\linewidth}
			\begin{figure}[H]
				\centering	
				\begin{tikzpicture}
					\draw[very thick, dashed](0,0) circle (1.5);
					\draw[very thick, dashed](5,0) circle (1.5);
					\node[vertex, label=left:{$i$}] (i) at (0.5,0) {};
					\node[vertex, label=right:{$k$}] (k) at (4.5,0) {};
					\draw (i) -- node {} (k);
					\draw[->, edge] (i) -- node {} (k);
					\node at (-1.5,1.1) {\large$\bar{S}$};
					\node at (6.5,1.1) {\large$S$};
				\end{tikzpicture}
				\caption{Случай 3: $i \in \bar{S}, k \in S$}
			\end{figure}
		\end{subfigure}
		\caption{Возможные случаи взаимного расположения вершин $i$ и $k$}
		\label{fig:ik_placement}
	\end{figure}
	
	Если $(i, k)$ относится к первому случаю, то её вклад в <<баланс>> через $\sum x_{lk}$ будет нивелировать её вклад в <<баланс>> через $\sum x_{il}$. Таким образом 
	
	\begin{align*}
		Z =& \; \sum_{l \in S} \bigg(\sum_{k:\;(l, k) \in J} x_{lk} - \sum_{i: \; (i, l) \in J} x_{il}\bigg) \\
		=& \;  \sum_{\underset{i \in S, k \in \bar{S}}{(i, k) \in J}} x_{ik} - \sum_{\underset{i \in \bar{S}, k \in S}{(i, k) \in J}} x_{ik} \\
		\le& \; \sum_{\underset{i \in S, k \in \bar{S}}{(i, k) \in J}} x_{ik}.
	\end{align*}
	
	По (2) из определения потока в сети:
	
	\begin{align*}
		Z \le& \; \sum_{\underset{i \in S, k \in \bar{S}}{(i, k) \in J}} x_{ik} \\
		\le& \sum_{\underset{i \in S, k \in \bar{S}}{(i, k) \in J}} b_{ik} \\
		=& \; B(S, \bar{S}).
	\end{align*}
	
	\item[\fbox{3}] Мы доказали, что
	\[
	\begin{cases}
		Z = v(x), \\
		Z \le B(S, \bar{S}); 
	\end{cases}
	\]
	\[
	\Downarrow
	\]
	\[
	v(x) \le B(S, \bar{S}).
	\]
\end{itemize}
